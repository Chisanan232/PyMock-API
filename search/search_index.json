{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home   PyMock-Server","text":"<p> PyMock-Server is a Python tool to mock API easily and humanly without any coding. </p>"},{"location":"#what-things-it-wants-to-resolve","title":"What things it wants to resolve?","text":"<p>Mock APIs through YAML file only, without any codes. And it also could easily and quickly set up a web server with the YAML format configuration.</p>"},{"location":"#why-it-is-easy-to-use","title":"Why it is easy to use?","text":"<p>It provides command line tool to help developers could set up a web server quickly.</p>"},{"location":"#why-it-is-humanly","title":"Why it is humanly?","text":"<p>Its configuration has been designed for humanly understand what settings the API has.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p> <p>PyMock-Server stands on the shoulder of giants:</p> <ul> <li> <p>Frameworks and tools for web server and WSGI or ASGI server.</p> <ul> <li>Flask with Gunicorn</li> <li>FastAPI with Uvicorn</li> </ul> </li> <li> <p>PyYAML for processing YAML format data.</p> </li> </ul>"},{"location":"command-line-usage/","title":"Command line usages","text":"<p>Currently, it doesn't have any options could use of command line <code>mock</code> without subcommand. The only one option which is useful is <code>--version</code> for checking current version info in your runtime environment.</p> <pre><code>&gt;&gt;&gt; mock &lt;option&gt;\n</code></pre>"},{"location":"command-line-usage/#-version","title":"<code>--version</code>","text":"<p>Show to details about version info in current runtime environment.</p>"},{"location":"command-line-usage/rest-server/","title":"Subcommand <code>rest-server</code> usage","text":"<p>If you try to mock HTTP server which through REST API to communicate between client side and server side, subcommand  <code>rest-server</code> must can help you to do that easily and quickly.</p> <pre><code>&gt;&gt;&gt; mock rest-server &lt;option&gt;\n</code></pre> <p>This subcommand line doesn't have any options but have multiple subcommand lines for processing different operation.</p>"},{"location":"command-line-usage/rest-server/#subcommand-run","title":"subcommand <code>run</code>","text":"<p>Set up a REST API server.</p>"},{"location":"command-line-usage/rest-server/#subcommand-get","title":"subcommand <code>get</code>","text":"<p>Get the details by the specific API from configuration.</p>"},{"location":"command-line-usage/rest-server/#subcommand-add","title":"subcommand <code>add</code>","text":"<p>Add new API into configuration.</p>"},{"location":"command-line-usage/rest-server/#subcommand-check","title":"subcommand <code>check</code>","text":"<p>Check the validation of configuration.</p>"},{"location":"command-line-usage/rest-server/#subcommand-sample","title":"subcommand <code>sample</code>","text":"<p>Display the valid example configuration.</p>"},{"location":"command-line-usage/rest-server/#subcommand-pull","title":"subcommand <code>pull</code>","text":"<p>Pull the API documentation detail setting from document host or document configuration as PyMock-Server configuration.</p>"},{"location":"command-line-usage/rest-server/subcmd-add/","title":"Subcommand <code>add</code> usage","text":"<p>Doing something operations about configuration or its content.</p> <pre><code>&gt;&gt;&gt; mock rest-server add &lt;option&gt;\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-api-config-path-api-configuration-file-path","title":"<code>--api-config-path</code> &lt;API configuration file path&gt;","text":"<p>Set the configuration file path to let this subcommand to operate with it.</p> <p>It receives a value which is the configuration file path and default value is <code>api.yaml</code>. It would face some scenarios:</p> <ul> <li> <p>File exists</p> <p>No matter it has valid content or not, it would add the new API into the existed configuration.</p> </li> <li> <p>File doesn't exist</p> <p>It would generate a new configuration file add the new API to it.</p> </li> </ul>"},{"location":"command-line-usage/rest-server/subcmd-add/#-base-url-base-api-path","title":"<code>--base-url</code> &lt;base API path&gt;","text":"<p>Set the base URL for deserialization of API documentation configuration.</p> <p>It receives a string value about the base URL path.</p>"},{"location":"command-line-usage/rest-server/subcmd-add/#-include-template-config","title":"<code>--include-template-config</code>","text":"<p>If it's <code>True</code>, it would set the template settings in the output configuration.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-add/#-base-file-path-directory-path","title":"<code>--base-file-path</code> &lt;directory path&gt;","text":"<p>The path which would be used as root path to find the other files.</p> <p>It receives a string value about the base path.</p>"},{"location":"command-line-usage/rest-server/subcmd-add/#-dry-run","title":"<code>--dry-run</code>","text":"<p>If it's <code>True</code>, it would run the <code>add</code> feature without result.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-add/#-api-path-url","title":"<code>--api-path</code> &lt;URL&gt;","text":"<p>Set the URL path of mocking API.</p> <p>It receives a string value and this is required option.</p> Set by command lineSet by YAML syntax <pre><code>--api-path '/foo-home'\n</code></pre> <pre><code>mocked_apis:\n  foo_home:\n    # some settings of API\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-http-method-http-method","title":"<code>--http-method</code> &lt;HTTP method&gt;","text":"<p>Set the HTTP method in request of mocking API.</p> <p>It receives a string value which should satisfy the value of HTTP method which be defined in RFC-2616.</p> Set by command lineSet by YAML syntax <pre><code>--http-method 'POST'\n</code></pre> <pre><code>mocked_apis:\n  foo_home:\n    request:\n      method: 'POST'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-parameters-json-format-string-value","title":"<code>--parameters</code> &lt;JSON format string value&gt;","text":"<p>Set the HTTP request parameters of mocking API.</p> <p>It receives a string value and default value is empty string. This option could be used multiple times.</p> Set by command lineSet by YAML syntax <pre><code>--parameters '{\"name\": \"arg1\", \"required\": true, \"type\": \"str\"}' --parameters '{\"name\": \"arg2\", \"required\": false, \"type\": \"int\", \"default\": 0}'\n</code></pre> <pre><code>mocked_apis:\n  foo_home:\n    request:\n      method: 'POST'\n      parameters:\n        - name: 'arg1'\n          required: true\n          type: str\n        - name: 'arg2'\n          required: false\n          type: int\n          default: 0\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-response-strategy-string-value","title":"<code>--response-strategy</code> &lt;String value&gt;","text":"<p>About setting the response part, it needs to set 2 values: strategy and properties. This option sets the strategy part.</p> <p>For the details of each strategy, please refer to the section HTTP response in Configuration references.</p> Set by command lineSet by YAML syntax <pre><code>--response-strategy 'string'\n</code></pre> <pre><code>mocked_apis:\n  foo_home:\n    request:\n      method: 'POST'\n      parameters:\n        - name: 'arg1'\n          required: true\n          type: str\n        - name: 'arg2'\n          required: false\n          type: int\n          default: 0\n    response:\n      strategy: string\n      value: 'This is PyTest demo.'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-response-value-string-value","title":"<code>--response-value</code> &lt;String value&gt;","text":"<p>About setting the response part, it needs to set 2 values: strategy and properties. This option sets the properties part which is the HTTP response value of mocking API.</p> <p>It receives a string value and default value is <code>OK.</code>.</p> <ul> <li>Set the value as string directly</li> </ul> <p>If the response strategy is <code>string</code> or <code>file</code>, it should use this option with that. It would set the option value as the setting value directly.</p> Set by command lineSet by YAML syntax <pre><code>--response-value 'This is foo.'\n</code></pre> <pre><code>mocked_apis:\n  foo_home:\n    request:\n      method: 'POST'\n      parameters:\n        - name: 'arg1'\n          required: true\n          type: str\n        - name: 'arg2'\n          required: false\n          type: int\n          default: 0\n    response:\n      strategy: string\n      value: 'This is foo.'\n</code></pre> <ul> <li>Set the value with some special properties</li> </ul> <p>If the response strategy is <code>object</code>, it should use this option with that. It should use JSON format string value to set its settings.</p> Set by command lineSet by YAML syntax <pre><code>--response-value '{\"name\": \"responseCode\", \"required\": True, \"type\": \"str\"}' --response-value '{\"name\": \"responseData\", \"required\": False, \"type\": \"str\"}'\n</code></pre> <pre><code>mocked_apis:\n  foo_home:\n    request:\n      method: 'POST'\n      parameters:\n        - name: 'arg1'\n          required: true\n          type: str\n        - name: 'arg2'\n          required: false\n          type: int\n          default: 0\n    response:\n      strategy: object\n      properties:\n        - name: responseCode\n          required: True\n          type: str\n          format:\n        - name: responseData\n          required: True\n          type: str\n          format:\n</code></pre> <p>Use command line or operate configuration directly?</p> <p>In general usage scenarios, it's okay to use any one of these 2 ways. However, if the  response properties are complex, it's better to set the value in configuration directly.</p>"},{"location":"command-line-usage/rest-server/subcmd-add/#-divide-api","title":"<code>--divide-api</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about mocked API part to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-divide-http","title":"<code>--divide-http</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about the HTTP part of each mocked APIs to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-divide-http-request","title":"<code>--divide-http-request</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about the request part in HTTP section of each mocked APIs to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-add/#-divide-http-response","title":"<code>--divide-http-response</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about the response part in HTTP section of each mocked APIs to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-check/","title":"Subcommand <code>check</code> usage","text":"<p>Check the validity of configuration content.</p> <pre><code>&gt;&gt;&gt; mock rest-server check &lt;option&gt;\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-check/#-config-path-or-p-config-file-path","title":"<code>--config-path</code> or <code>-p</code> &lt;config-file-path&gt;","text":"<p>Set the target configuration file for checking.</p> <p>It receives a value about the configuration file path and its default value is <code>api.yaml</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-check/#-stop-if-fail-boolean-value","title":"<code>--stop-if-fail</code> &lt;Boolean value&gt;","text":"<p>If it's <code>True</code>, it would terminate directly if it detects any issue. If it's <code>False</code>, it would detect and show all issues and exit program with exit code 1 finally.</p> <p>It receives a boolean value and default value is <code>False</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-check/#-swagger-doc-url-or-s-swagger-api-document-url-or-host-address","title":"<code>--swagger-doc-url</code> or <code>-s</code> &lt;Swagger API document URL or host address&gt;","text":"<p>The URL or host address of Swagger API document. It would compare current API config all details (which be set by option <code>--config-path</code>) with the API details of this Swagger API document.</p> <p>It receives a string value.</p>"},{"location":"command-line-usage/rest-server/subcmd-check/#-check-entire-api","title":"<code>--check-entire-api</code>","text":"<p>If it's <code>True</code>, check the entire API settings includes API path, HTTP method and request parameters.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-check/#-check-api-path","title":"<code>--check-api-path</code>","text":"<p>If it's <code>True</code>, check whether the API exist or not by URL path.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-check/#-check-api-http-method","title":"<code>--check-api-http-method</code>","text":"<p>If it's <code>True</code>, check the HTTP method of API.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-check/#-check-api-parameters","title":"<code>--check-api-parameters</code>","text":"<p>If it's <code>True</code>, check the request parameters of API.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-get/","title":"Subcommand <code>get</code> usage","text":"<p>Getting detail info with specific conditions for comprehensive inspection of configuration.</p> <pre><code>&gt;&gt;&gt; mock rest-server get &lt;option&gt;\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-get/#-config-path-or-p-config-file-path","title":"<code>--config-path</code> or <code>-p</code> &lt;config file path&gt;","text":"<p>Set the configuration file path.</p> <p>It receives a value about the configuration file path and its default value is <code>api.yaml</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-get/#-show-detail-or-s","title":"<code>--show-detail</code> or <code>-s</code>","text":"<p>Get the configuration details if activate this command line option. Nor PyMock-Server would only tell you the setting  with the API exists without any info.</p> <p>It doesn't accept any value.</p>"},{"location":"command-line-usage/rest-server/subcmd-get/#-show-as-format-or-f-output-info-format","title":"<code>--show-as-format</code> or <code>-f</code> &lt;output-info-format&gt;","text":"<p>Display the configuration details as one specific format.</p> <p>It receives a string value about format of configuration details, and it has default value <code>text</code>. All the values you could use at this command line option are:</p> <ul> <li><code>text</code></li> <li><code>yaml</code></li> <li><code>json</code></li> </ul>"},{"location":"command-line-usage/rest-server/subcmd-get/#-api-path-or-a-api-path","title":"<code>--api-path</code> or <code>-a</code> &lt;API path&gt;","text":"<p>The condition uses API path for getting the relative configuration which URL setting is the API path.</p> <p>It receives a string value about the API path.</p>"},{"location":"command-line-usage/rest-server/subcmd-get/#-http-method-or-m-http-method","title":"<code>--http-method</code> or <code>-m</code> &lt;HTTP method&gt;","text":"<p>The condition uses HTTP method of API path for getting the relative configuration which URL setting is the API path and HTTP method setting is same as the option value.</p> <p>It receives a string value about the HTTP method of API path.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/","title":"Subcommand <code>pull</code> usage","text":"<p>If it has already had API documentation, e.g., OpenAPI format (aka Swagger API), provides the API details, you could use <code>pull</code> feature to fetch it as PyMock-Server format configuration and set up HTTP server for mocking API easily and  quickly.</p> Why we need sub-command line <code>pull</code>? <p>Let's consider one scenario, the system has already provide service for a while  and it has so many APIs which have already be used awhile. However, you want to  import this tool for Font-End site development, but it's too hard to configure  all existing APIs into PyMock-Server configuration. At this time, <code>pull</code>  feature could give you a hand to handle it easily and quickly.</p> <pre><code>&gt;&gt;&gt; mock rest-server pull &lt;option&gt;\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-source-or-s-api-document-url","title":"<code>--source</code> or <code>-s</code> &lt;API document URL&gt;","text":"<p>Set the source that is the endpoint of OpenAPI document it would try to get the API documentation configuration and  convert it as PyMock-Server format configuration.</p> <p>It receives a string value about the host address or URL path.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-source-file-or-f-api-document-configuration-file","title":"<code>--source-file</code> or <code>-f</code> &lt;API document configuration file&gt;","text":"<p>Set the source file that is the specific file it would try to get the API documentation configuration and convert it  as PyMock-Server format configuration.</p> <p>It receives a string value about the configuration file path.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-base-url-base-api-path","title":"<code>--base-url</code> &lt;base API path&gt;","text":"<p>Set the base URL for deserialization of API documentation configuration.</p> <p>It receives a string value about the base URL path.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-config-path-or-c-config-file-path","title":"<code>--config-path</code> or <code>-c</code> &lt;config file path&gt;","text":"<p>The file path for saving configuration which be fetched and be deserialized from the API documentation configuration to  PyMock-Server format.</p> <p>It receives a string value about the configuration file path.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-request-with-https","title":"<code>--request-with-https</code>","text":"<p>If it's <code>True</code>, it would find the Swagger API documentation host through <code>HTTPS</code>, or it does through <code>HTTP</code> directly.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-base-file-path-directory-path","title":"<code>--base-file-path</code> &lt;directory path&gt;","text":"<p>The path which would be used as root path to find the other files.</p> <p>It receives a string value about the base path.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-include-template-config","title":"<code>--include-template-config</code>","text":"<p>If it's <code>True</code>, it would set the template settings in the output configuration.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-dry-run","title":"<code>--dry-run</code>","text":"<p>If it's <code>True</code>, it would run the <code>pull</code> feature without result.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-divide-api","title":"<code>--divide-api</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about mocked API part to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-divide-http","title":"<code>--divide-http</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about the HTTP part of each mocked APIs to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-divide-http-request","title":"<code>--divide-http-request</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about the request part in HTTP section of each mocked APIs to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-pull/#-divide-http-response","title":"<code>--divide-http-response</code>","text":"<p>If it's <code>True</code>, it would divide the configuration about the response part in HTTP section of each mocked APIs to another single file.</p> <p>It doesn't accept any value and default is <code>False</code>. It's <code>True</code> if set this option.</p> <p>Let's demonstrate an example configuration for you. Below is a general entire configuration. If you set this option, it would divide the highlight part and save it to another single file.</p> <pre><code>name: ''\ndescription: ''\nmocked_apis:\n  base:\n    url: '/api/v1/test'\n  apis:\n    get_foo:\n      url: '/foo'\n      http:\n        request:\n          method: 'GET'\n          parameters:\n            - name: 'date'\n              required: true\n              default:\n              type: str\n              format:\n            - name: 'fooType'\n              required: true\n              default:\n              type: str\n              format:\n        response:\n          strategy: object\n          properties:\n            - name: errorMessage\n              required: True\n              type: str\n              format:\n            - name: responseCode\n              required: True\n              type: str\n              format:\n            - name: responseData\n              required: False\n              type: list\n              format:\n              items:\n                - name: id\n                  required: True\n                  type: int\n                - name: name\n                  required: True\n                  type: str\n                - name: value1\n                  required: True\n                  type: str\n                - name: value2\n                  required: True\n                  type: str\n      tag: 'foo'\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-run/","title":"Subcommand <code>run</code> usage","text":"<p>Activate and run a web server which could provide all the APIs be configured in <code>.yaml</code> configuration file. The way for running the web server would be different if the web library is different so that the log message would be different.</p> <pre><code>&gt;&gt;&gt; mock rest-server run &lt;option&gt;\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-run/#-config-or-c-config-file-path","title":"<code>--config</code> or <code>-c</code> &lt;config-file-path&gt;","text":"<p>Set the configuration file path. PyMock-Server would use the settings to configure the APIs.</p> <p>It receives a value about the configuration file path and its default value is <code>api.yaml</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-run/#-app-type-python-web-library","title":"<code>--app-type</code> &lt;Python-web-library&gt;","text":"<p>Set one of Python web framework which would be the code base of the web server for mocking APIs.</p> <p>It receives a value about the Python web framework. The options it accepts are <code>auto</code>, <code>flask</code> and <code>fastapi</code>.</p> <ul> <li> <p><code>auto</code></p> <p>It would automatically detect which Python web framework it could use in current runtime environment. If it doesn't have any web framework could use, it would exit the program finally.</p> </li> <li> <p><code>flask</code></p> <p>Use Python web framework Flask to be the code base of the web server for mocking APIs.</p> </li> <li> <p><code>fastapi</code></p> <p>Use Python web framework FastAPI to be the code base of the web server for mocking APIs.</p> </li> </ul> <p>Its default value is <code>auto</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-run/#-bind-or-b-host-address","title":"<code>--bind</code> or <code>-b</code> &lt;host-address&gt;","text":"<p>Set the host to bind with the web server.</p> <p>It receives a value about the host address which should includes IP address and port. Its default value is <code>0.0.0.0:9672</code>.</p> <p>Why the default port is 9672?</p> <p>The port number could be divides into 2 parts: 96 and 72. These 2 number mean an important thing in history: In 1996, the NBA G.O.A.T Michael Jordan leaded the Chicago Bulls team won 72 games and won the NBA champion in that season finally. He has keeped making history and has so many unbelievable records in NBA history. Therefore, PyMock-Server uses the port number 9672 to remember the things this legend made.</p>"},{"location":"command-line-usage/rest-server/subcmd-run/#-workers-or-w-workers","title":"<code>--workers</code> or <code>-w</code> &lt;workers&gt;","text":"<p>Set the amount how many workers does it process the requests of web server.</p> <p>It receives a value about the amount of workers and its default value is <code>1</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-run/#-log-level-level","title":"<code>--log-level</code> &lt;level&gt;","text":"<p>Set the log level of web server what info it should export.</p> <p>It receives a value about the log level and its default value is <code>info</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-sample/","title":"Subcommand <code>sample</code> usage","text":"<p>Doing something operations about configuration or its content.</p> <pre><code>&gt;&gt;&gt; mock rest-server sample &lt;option&gt;\n</code></pre>"},{"location":"command-line-usage/rest-server/subcmd-sample/#-print-sample-or-p","title":"<code>--print-sample</code> or <code>-p</code>","text":"<p>Show the sample configuration which could be used directly by PyMock-Server.</p> <p>It doesn't accept any value.</p>"},{"location":"command-line-usage/rest-server/subcmd-sample/#-generate-sample-or-g","title":"<code>--generate-sample</code> or <code>-g</code>","text":"<p>Generating the sample configuration as a <code>.yaml</code> file. The configuration content is same as the output of running result with option <code>--print-sample</code>.</p> <p>It doesn't accept any value.</p>"},{"location":"command-line-usage/rest-server/subcmd-sample/#-output-or-o-output-file-path","title":"<code>--output</code> or <code>-o</code> &lt;output-file-path&gt;","text":"<p>Generating the sample configuration to the target output file path.</p> <p>It receives a value about the configuration file path, and it doesn't have default value. It would exit the program and output error message if it doesn't have value of this option when using option <code>--generate-sample</code>.</p>"},{"location":"command-line-usage/rest-server/subcmd-sample/#-sample-config-type-or-t-sample-config-type","title":"<code>--sample-config-type</code> or <code>-t</code> &lt;sample config type&gt;","text":"<p>Which sample configuration it should generate. Currently, it has 4 types:</p> <ul> <li> <p><code>all</code></p> <p>The sample configuration which has 3 mocked APIs about each sample of <code>response_as_str</code>, <code>response_as_json</code> and <code>response_with_file</code>.</p> </li> <li> <p><code>response_as_str</code></p> <p>The sample configuration which has sample mocked API with response returns string value directly.</p> </li> <li> <p><code>response_as_json</code></p> <p>The sample configuration which has sample mocked API with response returns JSON format value.</p> </li> <li> <p><code>response_with-file</code></p> <p>The sample configuration which has sample mocked API with response as a file path. It would return the file content as response.</p> </li> </ul> <p>It receives a string value about the sample type and its default value is <code>all</code>.</p>"},{"location":"configure-references/config-basic-info/","title":"Configure basic information","text":"<p>Although here settings doesn't have any essentially function in web server currently. But it could let developers clear what the mocked API server does or which project or service it targets to provide to.</p>"},{"location":"configure-references/config-basic-info/#name","title":"<code>name</code>","text":"<p>The name of your web server for mocking APIs.</p>"},{"location":"configure-references/config-basic-info/#description","title":"<code>description</code>","text":"<p>Description for your web server. It recommends that describe some points of this web server to let developers could clear this server, i.e., what projects or services it targets to provide to? What the service does this web server mocks?</p>"},{"location":"configure-references/mocked-apis/","title":"Mocked API settings","text":"<p>This configuration section is the major function because here settings would decide how your mocked API works.</p>"},{"location":"configure-references/mocked-apis/#mocked_apis","title":"<code>mocked_apis</code>","text":"<p>Manage the API detail settings. The elements in it would be key-value map format. The key means the common feature or API name. The value means the detail settings of the common feature or API name.</p> <p>So what is the common feature? PyMock-Server provides some feature to let developers could to more convenience and clear of configuring mocked API. Following are the common features it provides currently:</p> <ul> <li>Basic information</li> </ul>"},{"location":"configure-references/mocked-apis/#template","title":"<code>template</code>","text":"<p>The template settings information of entire configuration for all mocked APIs. It would apply this section settings for scanning or finding the configuration files about the setting details of every mocked APIs.</p> <p>Here is the configuration details.</p>"},{"location":"configure-references/mocked-apis/#base","title":"<code>base</code>","text":"<p>The basic information of all APIs. It would apply this section settings for all APIs.</p> <p>Here is the configuration details.</p>"},{"location":"configure-references/mocked-apis/#api-name","title":"<code>&lt;API name&gt;</code>","text":"<p>The API you target to mock. The API name must be unique.</p> <p>Here is the configuration details.</p>"},{"location":"configure-references/mocked-apis/apis/","title":"Mocked API","text":"<p>This configuration section is the major function because here settings would decide how your mocked API works.</p>"},{"location":"configure-references/mocked-apis/apis/#mocked_apisapi-name","title":"<code>mocked_apis.&lt;API name&gt;</code>","text":"<p>The API you target to mock. The API name must be unique.</p> <p>About the detail settings of API, it has 3 major sections:</p> <ul> <li> <p>API URL (config)</p> <p>All settings about URL path.</p> </li> <li> <p>API HTTP request (config)</p> <p>All settings about how it should handle HTTP request.</p> </li> <li> <p>API HTTP response (config)</p> <p>All settings about how it should return HTTP response.</p> </li> </ul>"},{"location":"configure-references/mocked-apis/apis/url/","title":"URL","text":""},{"location":"configure-references/mocked-apis/apis/url/#mocked_apisapi-nameurl","title":"<code>mocked_apis.&lt;API name&gt;.url</code>","text":""},{"location":"configure-references/mocked-apis/apis/url/#general-url","title":"General URL","text":"<p>The URL path of API. Bellow are demonstrations the difference between only API and API with basic information settings:</p> API URL OnlyAPI URL with <code>base</code> settings <p>Only mocked API setting:</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo-home'\n</code></pre> <p>It's API URL path would be the path you set.</p> <pre><code>http://127.0.0.1:9672/foo-home\n</code></pre> <p>Mocked API setting with basic information setting:</p> <pre><code>mocked_apis:\n  base:\n    url: '/test/v1'\n  foo_home:\n    url: '/foo-home'\n</code></pre> <p>It's API URL path would need to add basic URL path in font of it.</p> <pre><code>http://127.0.0.1:9672/test/v1/foo-home\n</code></pre>"},{"location":"configure-references/mocked-apis/apis/url/#variable-in-url","title":"Variable in URL","text":"<p>If it exists variable(s) in URL, e.g., request something with one specific index which be set in URL, please use <code>&lt;&gt;</code> to set it.</p> API URL OnlyAPI URL with <code>base</code> settings <p>Only mocked API setting:</p> <pre><code>mocked_apis:\n  foo_process:\n    url: '/foo-process/&lt;item_id&gt;'\n</code></pre> <p>It's API URL path would be the path you set.</p> <pre><code>http://127.0.0.1:9672/foo-process/123\n</code></pre> <p>Mocked API setting with basic information setting:</p> <pre><code>mocked_apis:\n  base:\n    url: '/test/v1'\n  foo_process:\n    url: '/foo-process/&lt;item_id&gt;'\n</code></pre> <p>It's API URL path would need to add basic URL path in font of it.</p> <pre><code>http://127.0.0.1:9672/test/v1/foo-process/123\n</code></pre> <p>Doesn't support to access the variable(s) in response</p> <p>Currently, it doesn't support to access the variable(s) in anywhere like response.</p>"},{"location":"configure-references/mocked-apis/apis/http/","title":"HTTP","text":""},{"location":"configure-references/mocked-apis/apis/http/#mocked_apisapi-namehttp","title":"<code>mocked_apis.&lt;API name&gt;.http</code>","text":"<p>The detail settings about HTTP. It has 2 major sections need to configure: request and response.</p>"},{"location":"configure-references/mocked-apis/apis/http/#request","title":"<code>request</code>","text":"<p>This section is responsible for all settings of HTTP request.</p> <p>Here is the configuration details.</p>"},{"location":"configure-references/mocked-apis/apis/http/#response","title":"<code>response</code>","text":"<p>This section is responsible for all settings of HTTP response.</p> <p>Here is the configuration details.</p>"},{"location":"configure-references/mocked-apis/apis/http/request/","title":"Request","text":"<p><code>mocked_apis.&lt;API name&gt;.http.request</code></p> <p>This section is responsible for all settings of HTTP request.</p>"},{"location":"configure-references/mocked-apis/apis/http/request/#method","title":"<code>method</code>","text":"<p>The HTTP method which be accepted by API.</p>"},{"location":"configure-references/mocked-apis/apis/http/request/#parameters","title":"<code>parameters</code>","text":"<p>The parameter settings of API.</p>"},{"location":"configure-references/mocked-apis/apis/http/request/#parametersname","title":"<code>parameters[*].name</code>","text":"<p>The name of parameter.</p> <p>Example of usage:</p> HTTP method is GETHTTP method is POST <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo-home'\n    http:\n      request:\n        method: 'GET'\n        parameters:\n          - name: 'arg1'\n</code></pre> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo-home'\n    http:\n      request:\n        method: 'POST'\n        parameters:\n          - name: 'arg1'\n</code></pre> <p>Then you could use the parameter <code>arg1</code> of API <code>/foo-home</code>.</p> Send HTTP request by GET methodSend HTTP request by POST method <pre><code>curl -X GET http://127.0.0.1:9672/foo-home?arg1=value\n</code></pre> <pre><code>curl -X POST http://127.0.0.1:9672/foo-home -H 'Content-Type: application/json' -d '{\"arg1\":\"value\"}'\n</code></pre>"},{"location":"configure-references/mocked-apis/apis/http/request/#parametersrequired","title":"<code>parameters[*].required</code>","text":"<p>This is a boolean type value. If it's <code>true</code>, web server would respond 400 error if the request misses the argument. Nor it would ignore it.</p>"},{"location":"configure-references/mocked-apis/apis/http/request/#parametersdefault","title":"<code>parameters[*].default</code>","text":"<p>The default value of parameter. If the parameter in request is empty or <code>None</code> value, it would use this value to process.</p>"},{"location":"configure-references/mocked-apis/apis/http/request/#parameterstype","title":"<code>parameters[*].type</code>","text":"<p>The data type of the parameter value API should accept. The setting value should be a valid type for Python realm, i.e., string type value as <code>str</code>, integer type value as <code>int</code>, etc. </p> <p>Please refer to Python built-in types document to get more detail if you need.</p> <p>What data type you should use?</p> <p>As the description mention, the data type should be vallid for Python realm. Here provides some data type to help you configure your API parameters.</p> <ul> <li>Text type value: <code>str</code></li> <li>Integer type value: <code>int</code></li> <li>Boolean type value: <code>bool</code></li> <li>Some object of list type value: <code>list</code></li> <li>Key-value map type value: <code>dict</code></li> </ul>"},{"location":"configure-references/mocked-apis/apis/http/request/#parametersformat","title":"<code>parameters[*].format</code>","text":"<p>A regular expression of parameter value API should accept. It would respond 400 error if the parameter value format is not satisfied.</p>"},{"location":"configure-references/mocked-apis/apis/http/request/#parametersitems","title":"<code>parameters[*].items</code>","text":"<p>If the data type of parameter value is list type, it should use this key to configure its element details. The element detail  follow item element settings.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/","title":"Response","text":"<p><code>mocked_apis.&lt;API name&gt;.http.response</code></p> <p>This section is responsible for all settings of HTTP response.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#strategy","title":"<code>strategy</code>","text":"<p>About the HTTP response data format, it has 3 different strategies provide developers to set and use in their development.</p> <ul> <li> <p><code>string</code></p> <p>Return HTTP response as any format, any content which is string type value.</p> <p>Please refer to here to get more detail settings of this strategy.</p> </li> <li> <p><code>file</code></p> <p>The HTTP response content would be imported from one specific file as string type value.</p> <p>Please refer to here to get more detail settings of this strategy.</p> </li> <li> <p><code>object</code></p> <p>Express the HTTP response through object like software development. It's deeply recommended use this way to configure  HTTP response to be more clear and maintainable.</p> <p>Please refer to here to get more detail settings of this strategy.</p> </li> </ul>"},{"location":"configure-references/mocked-apis/apis/http/response/#string-strategy","title":"String strategy","text":""},{"location":"configure-references/mocked-apis/apis/http/response/#value","title":"<code>value</code>","text":"<p>The API response value it would use to return directly. It would try to parse data as JSON format, and it would respond  string type value if it parses fail.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#file-strategy","title":"File strategy","text":""},{"location":"configure-references/mocked-apis/apis/http/response/#path","title":"<code>path</code>","text":"<p>A file path which content is the API response value. It would detect the file extension and check whether it's valid or not.  If it is, it would try to access the file by the path to get the content as response value. If it isn't, it would raise an  exception FileFormatNotSupport.</p> <p>Currently, it only supports JSON file.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#object-strategy","title":"Object strategy","text":""},{"location":"configure-references/mocked-apis/apis/http/response/#properties","title":"<code>properties</code>","text":"<p>Express the response value as object of software realm. It accepts list type settings which would be combined as JSON format  value to return.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#propertiesname","title":"<code>properties[*].name</code>","text":"<p>The naming of value.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#propertiesrequired","title":"<code>properties[*].required</code>","text":"<p>Whether value is required to response or not.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#propertiestype","title":"<code>properties[*].type</code>","text":"<p>The data type of value. Please use Pythonic way to set this option.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#propertiesformat","title":"<code>properties[*].format</code>","text":"<p>The data format.</p> <p>Not support current but coming soon</p> <p>Currently, it just let you set this option. But it doesn't have essentially function to work.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#propertiesis_empty","title":"<code>properties[*].is_empty</code>","text":"<p>If the data type (property <code>properties[*].type</code>) is collection and is empty body, this option will be true. In the  other words, it would be valid about <code>properties[*].items</code> is empty when <code>properties[*].type</code> is collection with  this option is true.</p> <p>In generally, this option would be used for sub-command line <code>pull</code>.</p>"},{"location":"configure-references/mocked-apis/apis/http/response/#propertiesitems","title":"<code>properties[*].items</code>","text":"<p>If the data type of value is list type, it should use this key to configure its element details. The element detail follow  item element settings.</p> <p>Let's demonstrate the same HTTP response with each different strategies.</p> <p>For focussing on the HTTP response difference configuring with each strategy, it fixes all settings which is not relative  with response. And let's use value <code>{\"errorMessage\": \"\", \"responseCode\": \"200\", \"responseData\": [{\"id\": 1, \"name\": \"first ID\", \"value1\": \"demo value\"}]}</code>  to demonstrate.</p> HTTP response with string strategyHTTP response with file strategyHTTP response with object strategy <p>Set the value as string directly. If the value is more bigger, the configuration would be more harder to read and maintain. However, this is the easiest and quickest way to configure.</p> <p>The API configuration:</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo-strategy-demo'\n    http:\n      request:\n        method: 'GET'\n      response:\n        strategy: string\n        value: '{\"errorMessage\": \"\", \"responseCode\": \"200\", \"responseData\": [{\"id\": 1, \"name\": \"first ID\", \"value1\": \"demo value\"}]}'\n</code></pre> <p>The the value is too big to let developers read and maintain the configuration. It also could divide the value as content  in a single file to manage it. It could let the configuration to be more simpler. But it also would be a little bit annoying because you should read the setting between multiple different files.</p> <p>The API configuration:</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo-strategy-demo'\n    http:\n      request:\n        method: 'GET'\n      response:\n        strategy: file\n        path: ./demo-response-from-file.json\n</code></pre> <p>The JSON file <code>./demo-response-from-file.json</code> which saves the HTTP response:</p> <pre><code>{\n  \"errorMessage\": \"\", \n  \"responseCode\": \"200\", \n  \"responseData\": [\n    {\n      \"id\": 1, \n      \"name\": \"first ID\", \n      \"value1\": \"demo value\"\n    }\n  ]\n}\n</code></pre> <p>Set the response value as object of software developmenet. This way is the most flexible to maintain for developers  because it could set the details by each property of response value. But it also would let the settings to be more  longer in configuration. So it's obvious the configuration with this way is more complexer.</p> <p>The API configuration:</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo-strategy-demo'\n    http:\n      request:\n        method: 'GET'\n      response:\n        strategy: object\n        properties:\n          - name: errorMessage\n            required: True\n            type: str\n            format:\n          - name: responseCode\n            required: True\n            type: str\n            format:\n          - name: responseData\n            required: False\n            type: list\n            format:\n            items:\n              - name: id\n                required: True\n                type: int\n              - name: name\n                required: True\n                type: str\n              - name: value1\n                required: True\n                type: str\n</code></pre>"},{"location":"configure-references/mocked-apis/apis/http/common/","title":"Common schemas","text":"<p>Some property which would be commonly used.</p>"},{"location":"configure-references/mocked-apis/apis/http/common/#items","title":"<code>items</code>","text":"<p>This property is responsible for details setting of element in some data structure which is collection, e.g., list type  or map (aka dictionary in Python realm) type data.</p> <p>Here is the configuration details.</p>"},{"location":"configure-references/mocked-apis/apis/http/common/item_element/","title":"Item element","text":"<p><code>items element settings</code></p> <p>All the element of list type value follows these attributes to configure.</p>"},{"location":"configure-references/mocked-apis/apis/http/common/item_element/#itemsname","title":"<code>items[*].name</code>","text":"<p>The naming of item's value.</p>"},{"location":"configure-references/mocked-apis/apis/http/common/item_element/#itemsrequired","title":"<code>items[*].required</code>","text":"<p>Whether item's value is required to response or not.</p>"},{"location":"configure-references/mocked-apis/apis/http/common/item_element/#itemstype","title":"<code>items[*].type</code>","text":"<p>The data type of item's value. Please use Python built-in types to set this option.</p> <p>Currently, it only supports following data types: <code>str</code>, <code>int</code>, <code>bool</code>, <code>list</code>, <code>dict</code>.</p> <p>Usage notes</p> <p>If the type is collection, remember to set the option <code>items[*].items</code> for the detail settings of element in the collection.</p>"},{"location":"configure-references/mocked-apis/apis/http/common/item_element/#itemsitems","title":"<code>items[*].items</code>","text":"<p>If <code>items[*].type</code> is collection like <code>list</code> or <code>dict</code>, it must set this property for its details of element. And it is totally same as item element.</p> <p>Usage notes</p> <ul> <li>list of one specific type elements</li> </ul> <p>Configuration:</p> <pre><code>- name: sample_list\n  required: True\n  type: list\n  items:\n    - required: True\n      type: int\n</code></pre> <p>Result data:</p> <pre><code>{\"sample_list\": ['random integer']}\n</code></pre> <ul> <li>dict type data</li> </ul> <p>Configuration:</p> <pre><code>- name: sample_dict\n  required: True\n  type: dict\n  items:\n    - name: key_1\n      required: True\n      type: str\n    - name: key_2\n      required: True\n      type: int\n</code></pre> <p>Result data:</p> <pre><code>{\"sample_dict\": {'key_1': 'random string', 'key_2': 'random integer'}}\n</code></pre> <ul> <li>list of dict type elements</li> </ul> <p>Configuration:</p> <pre><code>- name: sample_list\n  required: True\n  type: list\n  items:\n    - name: key_1\n      required: True\n      type: str\n    - name: key_2\n      required: True\n      type: int\n</code></pre> <p>Result data:</p> <pre><code>{\"sample_list\": [{'key_1': 'random string', 'key_2': 'random integer'}]}\n</code></pre>"},{"location":"configure-references/mocked-apis/base/","title":"Base","text":"<p>This configuration section is the major function because here settings would decide how your mocked API works.</p>"},{"location":"configure-references/mocked-apis/base/#mocked_apisbase","title":"<code>mocked_apis.base</code>","text":"<p>The basic information of all APIs. It would apply this section settings for all APIs.</p>"},{"location":"configure-references/mocked-apis/base/#url","title":"<code>url</code>","text":"<p>The URL basic information of all APIs. It would apply the URL path to all API path. Let's give you an example to demonstrate:</p> <pre><code>mocked_apis:\n  base:\n    url: '/test/v1'\n</code></pre> <p>Base on above settings to configure your mocked API, you would need to add the URL path <code>/test/v1</code> in font of the URL path of all APIs. So your HTTP request URL would be like as below:</p> <pre><code>http://127.0.0.1:9672/test/v1&lt;API path&gt;\n</code></pre> <p>And it's an empty string if you omit this setting. In the other words, you could use the API URL path you set directly.</p>"},{"location":"configure-references/mocked-apis/template/","title":"Template","text":"<p>This configuration section could let your configuration be more clear and organized to read and manage. It let you could separate each major sections, e.g., a mocked API or a HTTP section of one mocked API, to a single file so that one configuration could be short and simple for reading easily.</p>"},{"location":"configure-references/mocked-apis/template/#mocked_apistemplate","title":"<code>mocked_apis.template</code>","text":"<p>The setting section for the template feature.</p>"},{"location":"configure-references/mocked-apis/template/#activate","title":"<code>activate</code>","text":"<p>Whether activating the template feature or not. It accepts a boolean type value.</p>"},{"location":"configure-references/mocked-apis/template/#load_config","title":"<code>load_config</code>","text":"<p>It's a setting section for some detail adjustments about loading configuration. Please refer to  here to get more details.</p>"},{"location":"configure-references/mocked-apis/template/#config_path_values","title":"<code>config_path_values</code>","text":"<p>It's a setting section for some detail setting for scanning file to load configuration. Please refer to  here to get more details.</p>"},{"location":"configure-references/mocked-apis/template/#apply","title":"<code>apply</code>","text":"<p>It's a setting section for some detail setting for applying some specific mocked APIs into entire configuration. Please refer to here to get more details.</p>"},{"location":"configure-references/mocked-apis/template/apply/","title":"Template apply setting","text":""},{"location":"configure-references/mocked-apis/template/apply/#mocked_apistemplateapply","title":"<code>mocked_apis.template.apply</code>","text":"<p>The section about detail settings of applying which mocked APIs into entire PyMock-Server configuration.</p>"},{"location":"configure-references/mocked-apis/template/apply/#api","title":"<code>api</code>","text":"<p>It accepts 2 kinds of data: just a list or a list of dict type element.</p> <ul> <li> <p>Just a list (Doesn't have tag)</p> <p>If it's just a list, the elements would are the file naming of all mocked API configurations which would be loaded into entire configuration.</p> <pre><code>apply:\n  api:\n    - get_foo\n    - get_foo-boo\n</code></pre> </li> <li> <p>A list of dict type element (Have tag for grouping mocked APIs)</p> <p>If it's just a list of dict type element, the key is the tag of mocked APIs like group name and the value is the list of elements which are the file naming of all mocked API configurations for loading into entire configuration.</p> <pre><code>apply:\n  api:\n    - foo:    # This is the mocked API *get_foo*'s tag\n      - get_foo\n    - foo-boo:    # This is the tag for mocked APIs *get_foo-boo* and *put_foo-boo*\n      - get_foo-boo\n      - put_foo-boo\n</code></pre> </li> </ul> <p>Only load the configuration it has in apply</p> <p>If your loading setting only set <code>apply</code>, it would ONLY load the mocked APIs which be set at the key <code>api</code> even it has other mocked APIs.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/","title":"Template values setting","text":""},{"location":"configure-references/mocked-apis/template/config_path_values/#mocked_apistemplateconfig_path_values","title":"<code>mocked_apis.template.config_path_values</code>","text":"<p>The section about detail settings of scanning file to load configuration.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#base_file_path","title":"<code>base_file_path</code>","text":"<p>The path is the base directory path for scanning or finding the configuration files.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#api","title":"<code>api</code>","text":"<p>The section about template value settings for mocked API part.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#apiconfig_path_format","title":"<code>api.config_path_format</code>","text":"<p>The file naming format to let program to find it.</p> <p>The feature doesn't finish yet</p> <p>The feature of this key doesn't complete yet. Currently, it suggests you only use format <code>**-xxx.yaml</code> to set it.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#http","title":"<code>http</code>","text":"<p>The section about template value settings for HTTP part of every mocked API.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#httpconfig_path_format","title":"<code>http.config_path_format</code>","text":"<p>The file naming format to let program to find it.</p> <p>The feature doesn't finish yet</p> <p>The feature of this key doesn't complete yet. Currently, it suggests you only use format <code>**-xxx.yaml</code> to set it.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#request","title":"<code>request</code>","text":"<p>The section about template value settings for HTTP request part of every mocked API.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#requestconfig_path_format","title":"<code>request.config_path_format</code>","text":"<p>The file naming format to let program to find it.</p> <p>The feature doesn't finish yet</p> <p>The feature of this key doesn't complete yet. Currently, it suggests you only use format <code>**-xxx.yaml</code> to set it.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#response","title":"<code>response</code>","text":"<p>The section about template value settings for HTTP response part of every mocked API.</p>"},{"location":"configure-references/mocked-apis/template/config_path_values/#responseconfig_path_format","title":"<code>response.config_path_format</code>","text":"<p>The file naming format to let program to find it.</p> <p>The feature doesn't finish yet</p> <p>The feature of this key doesn't complete yet. Currently, it suggests you only use format <code>**-xxx.yaml</code> to set it.</p>"},{"location":"configure-references/mocked-apis/template/load/","title":"Template loading setting","text":""},{"location":"configure-references/mocked-apis/template/load/#mocked_apistemplateload_config","title":"<code>mocked_apis.template.load_config</code>","text":"<p>The section about some detail settings of loading configuration.</p>"},{"location":"configure-references/mocked-apis/template/load/#includes_apis","title":"<code>includes_apis</code>","text":"<p>It accepts a boolean type value. If it's <code>True</code>, it would include the mocked APIs which is in section <code>mocked_apis.apis</code> to load configuration, and vice versa.</p> <p>For scanning file</p> <p>No matter it's <code>True</code> or <code>False</code>, it would try to load mocked APIs setting to configuration by scanning file.</p>"},{"location":"configure-references/mocked-apis/template/load/#order","title":"<code>order</code>","text":"<p>It accepts a list type value. It could adjust the loading order. In PyMock-Server realm, it has 3 ways to load configuration:</p> <ul> <li> <p><code>apis</code></p> <p>Load the mocked APIs from the section <code>mocked_apis.apis</code>.</p> </li> <li> <p><code>apply</code></p> <p>Load the specific mocked APIs by the section <code>mocked_apis.template.apply.api</code>.</p> </li> <li> <p><code>file</code></p> <p>Load the mocked APIs by scanning file.</p> </li> </ul> <p>Besides controlling order, also can control which way to load</p> <p>In addition to controlling the order to load configuration, it depends on the  list to load configuration one by one, so it also could use this option to control which ways you want it to load ONLY.</p>"},{"location":"development/","title":"Development","text":"<p>This section for the developers who are curious or interesting of the detail implementation, design, etc. of PyMock-Server.</p> <p>The major points it would tell you are:</p> <ul> <li> <p>How it works exactly?</p> <p>It would tell you the running principle of PyMock-Server. So here includes some workflow of entire program and a little implementation.</p> </li> <li> <p>What the software architecture it is designed and implemented?</p> <p>All of here are everything about software design. So it has many UML, workflow between different objects and some details of them.</p> </li> </ul>"},{"location":"development/how-it-works/","title":"How it works","text":"<p>PyMock-Server would base on the settings of configuration to set up the web server to mock APIs without any code. But, how it exactly works? How it works of generating APIs which code base with the customized settings and Python web framework?</p> <p>Please consider one thing, the spec has been defined and be ready for developing, you need to develop a web server and provide some APIs for your partner who is responsible for Font-End site development. What things you would to do? I believe that the thing must be the same for everyone's answer in this world: </p> <ol> <li>Decide to use one specific Python web framework to develop (this one is optional because the project may be ready exist)</li> <li>Develop the API logic</li> <li>Set up to run the web server in a host</li> <li>Provide API to your Font-End partner</li> </ol> <p>Sometimes, you just want to mock an API, e.g., always return a fixed value, namely, you only set the response data at step 2. The code about API for mocking would also be more terrible as time passes by growing of API.</p> <p>For example, above steps with different Python web framework would be below (start at step 2):</p> FlaskFastAPI <ol> <li> <p>Mock API quickly by returned value directly as Python code</p> <pre><code>from flask import Flask\n\napp: Flask = Flask(__name__)\n\n# ... some code\n\n@app.route(\"/foo\", methods=[\"GET\"])\ndef foo_home() -&gt; dict:\n    return {\n        \"code\": \"200\",\n        \"errMsg\": \"OK\",\n        \"data\": \"This is Foo home API.\",\n    }\n\n# ... some code\n</code></pre> </li> <li> <p>Run the web server by WSGI server command line</p> <pre><code>&gt;&gt;&gt; gunicorn --bind 127.0.0.1:8080 'app:app'\n</code></pre> </li> </ol> <ol> <li> <p>Mock API quickly by returned value directly as Python code</p> <pre><code>from fastapi import FastAPI\n\napp: FastAPI = FastAPI()\n\n# ... some code\n\n@app.api_route(methods=[\"GET\"], path=\"/foo\")\ndef foo_home() -&gt; dict:\n    return {\n        \"code\": \"200\",\n        \"errMsg\": \"OK\",\n        \"data\": \"This is Foo home API.\",\n    }\n\n# ... some code\n</code></pre> </li> <li> <p>Run the web server by ASGI server command line</p> <pre><code>&gt;&gt;&gt; uvicorn --host 127.0.0.1 --port 8080 'app:app'\n</code></pre> </li> </ol> <p>For being convenience to manage includes maintaining or extending the API for mocking, PyMock-Server target to resolve this issue by automating the processes and configuring detail settings as <code>.yaml</code> file. The above workflows would be replaced and below are the details:</p> <ol> <li>Step 1 would be controlled by option <code>--app-type</code> under subcommand <code>run</code>. You even could run PyMock-Server without it because it would automatically detect it.</li> <li>Step 2, the API settings would be managed in a <code>.yaml</code> file. Don't write code, just configure with YAML.</li> <li>All things in step 3 would be simplified as one command line.</li> <li>Same, but they also could clearly get the API info by the configuration.</li> </ol> <p>In short, PyMock-Server to let your job about mocking API to be easier and more manageable.</p> <ol> <li> <p>Set the API for mocking as <code>.yaml</code> file and be named as <code>api.yaml</code></p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo'\n    http:\n      request:\n        method: 'GET'\n      response:\n        strategy: string\n        value: 'This is Foo home API.'\n</code></pre> </li> <li> <p>Run the web server</p> <pre><code>&gt;&gt;&gt; mock-api\n</code></pre> </li> </ol>"},{"location":"development/how-it-works/#application-layers","title":"Application layers","text":"<p>Let's virtualize the workflow of processing an HTTP request from application site to web server:</p> <p></p> <p>As you can see, the HTTP request would be sent from application by API. And it would be processed and return something by web server. The web server is the core component which you implement API by Python code. But wait a minute, it has another component be marked as SGI server. What's that? Do you remember what the command line to set up your web server? They're <code>gunicorn</code> for Flask and <code>uvicorn</code> for FastAPI. <code>gunicorn</code> is one of WSGI (Web server gateway interface) server implementation and <code>uvicorn</code> is one of ASGI (Asynchronous server gateway interface) server implementation. They could help your web server to be more efficiency of processing the HTTP requests. So your web server would be behind of SGI server in flow.</p> <p>PyMock-Server automates the process about write Python code to implement the API what data it should return and what SGI server you should use to set up and run your web server. And which web framework and SGI server you should use all could be controlled by option <code>--app-type</code>.</p>"},{"location":"development/how-it-works/#web-server","title":"Web server","text":"<p>Let's start to explain the running principle at web server part because it is the first thing everyone would do to mock API.</p> <p>Here's a sample setting as YAML format:</p> <pre><code>mocked_apis:\n  foo_home:    # Code line 8: function naming\n    url: '/foo'    # Code line 7: given parameters\n    http:\n      request:\n        method: 'GET'    # Code line 7: given parameters\n      response:\n        strategy: string    # Code line 9: given return data type is string\n        value: 'This is Foo home API.'    # Code line 9: given return value\n</code></pre> <ul> <li>The key of API setting <code>foo_home</code> would be the function naming in Python code.</li> <li>The value of keys <code>foo_home.url</code> and <code>foo_home.http.request.method</code> would be the parameter of routing function.</li> <li>The value of key <code>foo_home.http.response.value</code> would be the return value of function <code>foo_home</code>.</li> </ul> Python code by FlaskPython code by FastAPI <pre><code>from flask import Flask\n\napp: Flask = Flask(__name__)\n\n# ... some code\n\n@app.route(\"/foo\", methods=[\"GET\"])\ndef foo_home() -&gt; dict:\n    return 'This is Foo home API.'\n\n# ... some code\n</code></pre> <pre><code>from fastapi import FastAPI\n\napp: FastAPI = FastAPI()\n\n# ... some code\n\n@app.api_route(methods=[\"GET\"], path=\"/foo\")\ndef foo_home() -&gt; dict:\n    return 'This is Foo home API.'\n\n# ... some code\n</code></pre> <p>How it is clear and easy! Isn't it? So you won't need to copy and paste the code and modify the return value again and again. You just need to maintain the configuration only.</p>"},{"location":"development/how-it-works/#sgi-server-gateway-interface-server","title":"SGI (Server Gateway Interface) server","text":"<p>Except the API development by Python code, it also automates the command line running.</p> <p>PyMock-Server uses factory mode to create and set up application, and the factory function has been annotated in it so that we won't do anything about telling it where my application path as a string value.</p> <p>So the PyMock-Server command line you should use is very simple and easy.</p> <pre><code>mock-api --bind &lt;IP address&gt;:&lt;Port&gt; \\\n         --workers &lt;workers&gt; \\\n         --log-level &lt;log-level&gt;\n</code></pre> <p>And this command line would run the SGI server command as following:</p> If you're Flask, run by GunicornIf you're FastAPI, run by Uvicorn <pre><code>gunicorn --bind &lt;IP address&gt;:&lt;Port&gt; \\\n         --workers &lt;workers&gt; \\\n         --log-level &lt;log-level&gt; \\\n         'pymock_api.server:create_flask_app()'\n</code></pre> <pre><code>uvicorn --factory \\\n        --host &lt;IP address&gt; \\\n        --port &lt;Port&gt; \\\n        --workers &lt;workers&gt; \\\n        --log-level &lt;log-level&gt; \\\n        'pymock_api.server:create_fastapi_app'\n</code></pre> <p>Therefore, you don't worry and care about which SGI server you should use and how to use the command.</p> <p>That's mostly all the running principle of PyMock-Server.</p>"},{"location":"development/software-architecture/","title":"Software architecture","text":"<p>Software architecture is very important in a production because it's relative the flexibility and extensibility of the production. So it must have some designs applies to core functions codes.</p> <p>In PyMock-Server realm, it can divide to several sections to parse its software architecture:</p> <ul> <li> <p>Entry point of entire program</p> <ul> <li>Runner of command line</li> </ul> </li> <li> <p>Command line</p> <ul> <li>Entire command lines</li> <li>Entire command line options</li> </ul> </li> <li> <p>Features of command line</p> <ul> <li>Option <code>--config</code></li> <li>The sub-command line <code>run</code></li> </ul> </li> </ul> <p>Above all are some parts which have value or more complex to explain their details to developers.</p>"},{"location":"development/software-architecture/#program-entry-point-command-line-runner","title":"Program entry point - command line runner","text":"<p>The entry point of PyMock-Server command line tool. Its actually entry point is calling the function <code>run</code> in module <code>pymock_api.runner</code>.</p>"},{"location":"development/software-architecture/#uml","title":"UML","text":"<ul> <li>About the function which would be run as entry point <code>run</code>, it's a running logic of object <code>CommandRunner</code>.</li> <li>Object <code>CommandRunner</code> would keep instance of <code>ArgumentParser</code> and <code>CommandProcessor</code> to parse command line and run core logic of the current sub-command.</li> <li>Object <code>CommandRunner</code> would use function <code>dispatch_command_processor</code> to get the correct instance to handle current command line.</li> </ul>"},{"location":"development/software-architecture/#workflow","title":"Workflow","text":"<p>About workflow of command line runer, it uses 2 types sequence diagram to explain the relationship between different objects and functions.</p> <ul> <li>Sequence diagram</li> </ul> <p></p> <p>From the sequence diagram, you could observe that function <code>dispatch_command_processor</code> would keep getting the correct instances of <code>CommandProcessor</code> to run current command line.</p> <p>However, how it gets the correct object to process current command line? That's the reason having below activity sequence diagram to explain that:</p> <ul> <li>Activity sequence diagram for getting <code>CommandProcessor</code></li> </ul> <p></p> <p>In short, function <code>dispatch_command_processor</code> would iterate all instances of <code>CommandProcessor</code> to find the one which is responsible for current command line.</p> <p>Now you may have another question: it seems like that it has a <code>CommandProcessor</code> instance of list to let it find. So what is the list? When does the list would be generated?</p> <p>The answers of above would be in next section.</p>"},{"location":"development/software-architecture/#command-line-features","title":"Command line features","text":"<p>The core implementation of the command line. It would divide 2 sections here:</p> <ul> <li>Command line processors</li> <li>Command line options</li> </ul>"},{"location":"development/software-architecture/#command-line-processors","title":"Command line processors","text":"<p>The logic which would run by the current command line you enter.</p> <p>All codes belong to here section, they all are responsible for what thing would happen after user run the command line.</p>"},{"location":"development/software-architecture/#uml_1","title":"UML","text":"<ul> <li> <p>It has 4 base classes:</p> <ul> <li> <p><code>MetaCommand</code></p> <p>It's a metaclass for instantiating base class. It would auto-register objects which extends the base class be instantiated from this metaclass to list type protected variable <code>_COMMAND_CHAIN</code>.</p> </li> <li> <p><code>CommandProcessor</code></p> <p>It defines all attributes and functions for subclass to reuse or override to implement customize logic.</p> </li> <li> <p><code>BaseSubCmdComponent</code></p> <p>This is the base class should be extended by all subclasses which is the core running logic implementation of one specific sub-command line. And it also needs to be the return value of property <code>_subcmd_component</code> of each subclass which extends base class <code>CommandProcessor</code>.</p> </li> <li> <p><code>BaseCommandProcessor</code></p> <p>This is the base class which should be extended by all subclasses. This object be instantiated by metaclass <code>MetaCommand</code> and general object <code>CommandProcessor</code>.</p> </li> </ul> </li> <li> <p>The list be used by function <code>dispatch_command_processor</code> is protected variable <code>_COMMAND_CHAIN</code>.</p> </li> <li>All subclasses, i.e., <code>NoSubCmd</code>, <code>SubCmdRun</code>, etc., extend <code>BaseCommandProcessor</code> and implement what thing they need to do if user run the command includes returning which component they should use to run the core logic of the sub-command line.</li> <li>All subclasses, i.e., <code>NoSubCmdComponent</code>, <code>SubCmdRunComponent</code>, etc., extend <code>BaseSubCmdComponent</code> and implement the truly core logic of the sub-command line with its options.</li> </ul> The great idea about auto-register refer to source code of project Gunicorn <p>About the powerful design auto-register which has beautiful extension, it refers to the module config implementation of open source project Gunicorn. Please refer to its source code if you have interesting in it.</p>"},{"location":"development/software-architecture/#workflow_1","title":"Workflow","text":"<ul> <li>Sequence diagram</li> </ul> <p>From above sequence diagram, it does auto-registration when initialize an object. It won't do something to iterate all objects and save them to list type object, it automates all things when you add one or more new subclasses which is responsible for new sub-command line.</p>"},{"location":"development/software-architecture/#extension","title":"Extension","text":"<p>Here would demonstrate how to add one new sub-command processor in this software architecture.</p> <p>You'll have 3 things need to do:</p> <ul> <li>Command line argument</li> </ul> <p>New sub-command line must have options. So you need to define which sub-command line options it has.</p> <pre><code># In module pymock_server.model.cmd_args\n\n@dataclass(frozen=True)\nclass SubcmdNewProcessArguments(ParserArguments):\n    arg_1: str\n</code></pre> <ul> <li>Deserialization</li> </ul> <p>After defining new sub-command line's options, you should define how to deserialize it:</p> <pre><code># In module pymock_server.model.cmd_args\n\nclass DeserializeParsedArgs:\n\n    # ... some code\n\n    @classmethod\n    def subcommand_new_process(cls, args: Namespace) -&gt; SubcmdNewProcessArguments:\n        return SubcmdNewProcessArguments(\n            subparser_name=args.subcommand,\n            arg_1=args.arg_1,\n        )\n</code></pre> <p>And also defining the utility function at module __init__:</p> <pre><code># In module pymock_server.model.__init__\n\nclass deserialize_args:\n\n    # ... some code\n\n    @classmethod\n    def subcmd_new_process(cls, args: Namespace) -&gt; SubcmdNewProcessArguments:\n        return DeserializeParsedArgs.subcommand_new_process(args)\n</code></pre> <ul> <li>SubCommand process</li> </ul> <p>Now, it has sub-command line option data object and deserialization, we could implement what thing it should do.</p> <p>Here, we have 2 choices to implement: </p> <ol> <li>Override the function <code>_run</code> directly.</li> <li>Add new class extends class <code>BaseSubCmdComponent</code> and implement property <code>_subcmd_component</code>.</li> </ol> <p>Let's demonstrate all way to implement to you and explain their difference.</p> <ol> <li> <p>Override the function <code>_run</code> directly.</p> <p>In default, function <code>_run</code> would run the sub-command line core logic through the objects in component layer. In the other words, we also could override it directly without implement anything in component layer.</p> <ul> <li> <p>Pros:</p> <ul> <li>Decrease the number of class for implementing or maintaining.</li> <li>For the simple or easy logic, implement by this way could be more clear and short.</li> </ul> </li> <li> <p>Cons:</p> <ul> <li>For the complex logic or large-scale feature, implement by this way would let the code in this module to be dirty and   complex so that developers be more harder to manage or maintain it.</li> </ul> </li> </ul> <pre><code># In module pymock_api.command.process\n\n# ... some code\n\nclass SubCmdNewProcess(BaseCommandProcessor):\n    def _parse_process(self, parser: ArgumentParser, cmd_args: Optional[List[str]] = None) -&gt; SubcmdNewProcessArguments:\n        return deserialize_args.subcmd_new_process(self._parse_cmd_arguments(parser, cmd_args))\n\n    def _run(self, args: SubcmdNewProcessArguments) -&gt; None:\n        # Do something ...\n        print(f\"This is new sub-command line and get option *arg_1*: {args.arg_1}.\")\n</code></pre> </li> <li> <p>Add new class extends class <code>BaseSubCmdComponent</code> and implement property <code>_subcmd_component</code>.</p> <p>Implement and manage the core logic in component layer. And the command.process module only needs to know which component object is responsible of this feature.</p> <ul> <li> <p>Pros:</p> <ul> <li>Decoupling the logics sub-command line processor and core logic of the sub-command line.</li> <li>Could be more higher cohesion of the core logic of sub-command line with its options.</li> <li>No matter how the sub-command logic complex is, it still could be more easier and maitainable for management.</li> </ul> </li> <li> <p>Cons:</p> <ul> <li>More classes, more management.</li> <li>If the core logic is very easy and short, this way is a little laborious.</li> </ul> </li> </ul> <p>Implement the core logic in component layer:</p> <pre><code># In module pymock_api.command.new_subcmd.component\n\n# ... some code\n\nclass SubCmdNewProcessComponent(BaseSubCmdComponent):\n    def process(self, args: SubcmdNewProcessArguments) -&gt; None:\n        # Do something ...\n        print(f\"This is new sub-command line and get option *arg_1*: {args.arg_1}.\")\n</code></pre> <p>Remember that it needs to let command line processor know which component object it should use to run the sub-command line core logic:</p> <pre><code># In module pymock_api.command.process\n\n# ... some code\n\nclass SubCmdNewProcess(BaseCommandProcessor):\n    @property\n    def _subcmd_component(self) -&gt; SubCmdRunComponent:\n        return SubCmdNewProcessComponent()\n\n    def _parse_process(self, parser: ArgumentParser, cmd_args: Optional[List[str]] = None) -&gt; SubcmdNewProcessArguments:\n        return deserialize_args.subcmd_new_process(self._parse_cmd_arguments(parser, cmd_args))\n</code></pre> </li> </ol> <p>We finish all things if we want to extend one new sub-command line! Let's try to run it:</p> <pre><code>&gt;&gt;&gt; mock new-ps --arg-1 test_value\n</code></pre> <p>Unfortunately, you would get an error finally. Why? What you miss? Do you remember all the code in this software architecture only process the logic it should run by the current command line? But, how does it parse the command line and its options? So next section would tell you how to add new sub-command line and its options in their software architecture.</p>"},{"location":"development/software-architecture/#command-line-options","title":"Command line options","text":"<p>The logic which would parse the current command line and run something for it.</p> <p>All codes belong to here section, they all are responsible for defining the command line and its options to let argpars understands how to parse the current command line.</p>"},{"location":"development/software-architecture/#uml_2","title":"UML","text":"<p>The software architecture here feature apply is mostly same as previous one section Command line processors.</p> <ul> <li> <p>It has 3 base classes:</p> <ul> <li> <p><code>MetaCommandOption</code></p> <p>It's a metaclass for instantiating base class. It would auto-register objects which extends the base class be instantiated from this metaclass to list type data <code>COMMAND_OPTIONS</code>. If it is sub-command, it also saves sub-command line string to list type data <code>SUBCOMMAND</code>.</p> </li> <li> <p><code>CommandOption</code> (includes all subclasses of <code>BaseSubCommand</code>)</p> <p>It defines all attributes and functions for subclass to reuse or override to implement customize logic.</p> </li> <li> <p><code>BaseCmdOption</code>, <code>BaseSubCmdRunOption</code>, etc.</p> <p>This is the base class which should be extended by all subclasses. This object be instantiated by metaclass <code>MetaCommandOption</code> and general object <code>CommandOption</code>.</p> </li> </ul> </li> <li> <p>Every sub-command has their own base class. For example, sub-command line <code>run</code> with <code>BaseSubCmdRunOption</code>, <code>config</code> with <code>BaseSubCmdConfigOption</code> and so on.</p> </li> <li>The list be used by function <code>get_all_subcommands</code> is variable <code>SUBCOMMAND</code>.</li> <li>The list be used by function <code>make_options</code> is variable <code>COMMAND_OPTIONS</code>.</li> <li>All subclasses, i.e., <code>Version</code> extends <code>BaseCmdOption</code>, <code>WebAppType</code> extends <code>BaseSubCmdRunOption</code>, <code>ConfigPath</code> extends <code>BaseSubCmdConfigOption</code>, etc., means the specific options under the sub-command line.</li> </ul>"},{"location":"development/software-architecture/#workflow_2","title":"Workflow","text":"<p>Because the software architecture of here section is mostly same with Command line processors, its workflow also could refer to its workflow.</p>"},{"location":"development/software-architecture/#extension_1","title":"Extension","text":"<p>Here would demonstrate how to extend or add new sub-command feature.</p> <p>You'll have 4 things:</p> <ul> <li>Add new attribute of data object SubCommand</li> </ul> <p>Object <code>SubCommand</code> is the standard for PyMock-Server to recognize which sub-command it has. So let's add one new sub-command line here:</p> <pre><code># In module pymock_server.command.options\n\n@dataclass\nclass SubCommand:\n    Base: str = \"subcommand\"\n    Run: str = \"run\"\n    Config: str = \"config\"\n    Check: str = \"check\"\n    NewProcess: str = \"new-ps\"\n</code></pre> <ul> <li>Implement new class about subcommand <code>new-ps</code></li> </ul> <p>Add new class extends base class <code>BaseSubCommand</code> and set value at attribute <code>sub_parser</code>.</p> <pre><code># In module pymock_server.command.options\n\nclass SubCommandNewProcessOption(BaseSubCommand):\n    sub_parser: SubParserAttr = SubParserAttr(\n        name=SubCommand.NewProcess,\n        help=\"New subcommand for demonstration,\",\n    )\n</code></pre> <ul> <li>Instantiate class with metaclass for subcommand <code>new-ps</code></li> </ul> <p>Instantiate a base class for adding options.</p> <pre><code># In module pymock_server.command.options\n\nBaseSubCmdNewProcessOption: type = MetaCommandOption(\"BaseSubCmdNewProcessOption\", (SubCommandNewProcessOption,), {})\n</code></pre> <p>It would auto-register this sub-command line into <code>SUBCOMMAND</code>. We have sub-command line <code>new-ps</code>, let's add its options.</p> <ul> <li>Extend the subcommand object to add its option(s)</li> </ul> <p>Add new command option with extending <code>BaseSubCmdNewProcessOption</code> and set needed attributes in it:</p> <pre><code># In module pymock_server.command.options\n\nclass Arg_1(BaseSubCmdNewProcessOption):\n\n    cli_option: str = \"--arg-1\"\n    name: str = \"arg_1\"\n    help_description: str = \"A parameter for demonstration of extending new subcommand and new option.\"\n</code></pre> <ul> <li><code>cli_option</code>: Define the option usage via command line.</li> <li><code>name</code>: The attribute to get the option value from argpars.</li> <li><code>help_description</code>: The description would be displayed if you run <code>--help</code>.</li> </ul> <p>Finally, don't forget to let command line process know which sub-command line is its responsibility by overriding the class attribute <code>responsible_subcommand</code>:</p> <pre><code># In module pymock_server.command.process\n\n# ... some code\n\nclass SubCmdNewProcess(BaseCommandProcessor):\n    responsible_subcommand = SubCommand.NewProcess\n\n    # ... some code\n</code></pre> <p>Now, let's try to run the PyMock-Server with new sub-command:</p> <pre><code>&gt;&gt;&gt; mock new-ps --arg-1 test_value\nThis is new sub-command line and get option *arg_1*: test_value\n</code></pre> <p>Congratulation! It works finely as out expect.</p>"},{"location":"development/software-architecture/#subcommand-features","title":"SubCommand features","text":"<p>The features which be run in each command lines.</p>"},{"location":"development/software-architecture/#option-config-file-operation","title":"Option <code>--config</code> - file operation","text":"<p>Here focus on a small part --- a feature of one specific option <code>--config</code> under sub-command <code>run</code>.</p>"},{"location":"development/software-architecture/#uml_3","title":"UML","text":"<ul> <li>Object <code>MockHTTPServer</code> uses function <code>load_config</code> to get all detail settings.</li> <li>Data object <code>APIConfig</code> provides function to read and deserialize the configuration file content.</li> <li>Currently, it only supports parsing YAML file by object <code>YAML</code>.</li> </ul>"},{"location":"development/software-architecture/#extension_2","title":"Extension","text":"<p>Here demonstrate how to extend this feature to parse other file formatter.</p> <ul> <li>File operation</li> </ul> <p>If you want to use other file formatter, e.g., JSON, you could extend the base class of file operation _<code>BaseFileOperation</code> to implement needed features.</p> <pre><code># In module pymock_server.command.options\n\n# ... some code\n\nclass JSON(_BaseFileOperation):\n    def read(self):\n        # Read the configuration file content\n\n    def write(self, path: str, config: Union[str, dict]) -&gt; None:\n        # Write data into file\n\n    def serialize(self, config: dict) -&gt; str:\n        # Serialize dat object to string value\n</code></pre> <p>Because currently it won't have option in command line to control which way it should use to serialize or deserialize configuration file, so we need to manually modify the code to use it.</p> <pre><code># In module pymock_server.model.api_config\n\nclass APIConfig(_Config):\n    \"\"\"*The entire configuration*\"\"\"\n\n    _name: str = \"\"\n    _description: str = \"\"\n    _apis: Optional[MockAPIs]\n\n    _configuration: _BaseFileOperation = JSON()\n\n    def __init__(self, name: str = \"\", description: str = \"\", apis: Optional[MockAPIs] = None):\n        self._name = name\n        # ... some code\n</code></pre> <p>Finally, we could use JSON type file as our configuration formatter.</p> <pre><code>&gt;&gt;&gt; mock -c ./api.json\n</code></pre>"},{"location":"development/software-architecture/#run-web-server","title":"<code>run</code> - web server","text":"<p>This is the core feature of PyMock-Server. It does 2 things:</p> <ul> <li>Set up web application with the API from the detail settings of configuration.</li> <li>Run the web application by SGI server.</li> </ul>"},{"location":"development/software-architecture/#uml_4","title":"UML","text":"<ul> <li>The sub-command line processor <code>SubCmdRun</code> would use function <code>setup_wsgi</code> or <code>setup_asgi</code> to run the web application.</li> <li>All the way to run web application by factory pattern in PyMock-Server.</li> <li>The functions as factory callee to set up web application is <code>create_flask_app</code> and <code>create_fastapi_app</code>.</li> <li>Functions <code>create_flask_app</code> or <code>create_fastapi_app</code> would use adapter <code>MockHTTPServer</code> to set up all APIs as Python code with Python web framework Flask or FastAPI.</li> </ul>"},{"location":"development/software-architecture/#extension_3","title":"Extension","text":"<p>If you have your own customize Python web framework, you also could extend this features by your own one.</p> <p>Here would demonstrate how to extend it to implement your own web server.</p> <p>First, the entire web server should be divided to 2 parts:</p> <ul> <li>Server implementation from Python web framework</li> <li>Server gateway interface (a.k.a SGI) server</li> </ul> <p>They mean you should extend all below classes to implement:</p> <ul> <li> <p>For setting up web application by generating Python code</p> <ul> <li><code>BaseAppServer</code></li> </ul> </li> <li> <p>For running web application by SGI server</p> <ul> <li><code>BaseSGIServer</code></li> <li><code>BaseCommandOption</code></li> </ul> </li> </ul> <p>Don't forget it also needs to import the Python web framework into PyMock-Server to let it could generate Python code about APIs with configuration.</p> <ul> <li>Import web library</li> </ul> <p>2 Things you need to implement: importing the web framework and check importing the web framework.</p> <pre><code># In module pymock_server._utils.importing\n\nclass import_web_lib:\n\n    # Some code ...\n\n    @staticmethod\n    def foo_web_lib() -&gt; \"foo_web_lib\":\n        import foo_web_lib\n\n        return foo_web_lib\n\n    # Some code ...\n\n    @staticmethod\n    def foo_web_lib_ready() -&gt; bool:\n        return import_web_lib._chk_lib_ready(import_web_lib.foo_web_lib)\n</code></pre> <p>Importing way may be different with different web framework</p> <p>The importing way should be based on how to use the customized Python web framework.</p> <ul> <li><code>BaseAppServer</code></li> </ul> <p>Extend the web application feature about how PyMock-Server should set up it? How to initial the web application by the customized Python web framework? How to add new API by the customized web framework?</p> <pre><code># In module pymock_server.server.application\n\nclass FooWebLibrary(BaseAppServer):\n    def setup(self) -&gt; \"foo_web_lib.Foo\":\n        # How to set up web application instance by this web library\n        return import_web_lib.foo_web_lib().Foo(__name__)\n\n    def _add_api(self, api_name: str, api_config: MockAPI, base_url: Optional[str] = None) -&gt; str:\n        # How to add API by this web library\n        return f\"\"\"self.web_application.add_web_route(\n            path=\"{self.url_path(api_config, base_url)}\", methods=[\"{cast(HTTPRequest, self._ensure_http(api_config, \"request\")).method}\"]\n            )({api_name})\n        \"\"\"\n</code></pre> <ul> <li><code>BaseSGIServer</code></li> </ul> <p>Implement how to run web application by your own customized Python web framework. In exactly, it just generates a command line with options.</p> <pre><code># In module pymock_server.server.sgi.cmd\n\nclass FooSGIServer(BaseSGIServer):\n    def _init_cmd_option(self) -&gt; BaseCommandOption:\n        return FooWebSGIServerCmdOption()\n\n    @property\n    def entry_point(self) -&gt; str:\n        return \"foonicorn\"\n</code></pre> <ul> <li><code>BaseCommandOption</code></li> </ul> <p>Previous one implement the command line entry point, here implement each options how to set it.</p> <pre><code># In module pymock_server.server.sgi.cmdoption\n\nclass FooWebSGIServerCmdOption(BaseCommandOption):\n    def bind(self, address: Optional[str] = None, host: Optional[str] = None, port: Optional[str] = None) -&gt; str:\n        # Set the option about binding the service at one or more specific hosts\n        if address:\n            self._is_valid_address(address)\n            binding_addr = address\n        elif host and port:\n            binding_addr = f\"{host}:{port}\"\n        else:\n            raise ValueError(\"There are 2 ways to pass arguments: using *address* or using *host* and *port*.\")\n        return f\"--bind {binding_addr}\"\n\n    def workers(self, w: int) -&gt; str:\n        # Set the option about how many workers could handle the requests\n        return f\"--workers {w}\"\n\n    def log_level(self, level: str) -&gt; str:\n        # Set the option about log level\n        return f\"--log-level {level}\"\n</code></pre> <p>Now, we have done the core implementation, then we just leave some utility functions which we need to add.</p> <ul> <li>Utility function in module <code>pymock_api.server.sgi.__init__</code></li> </ul> <pre><code># In module pymock_server.server.sgi.__init__\n\nclass setup_server_gateway:\n    # Some code ...\n\n    @classmethod\n    def foo(cls, web_app: Union[str, Callable], module_dict: Optional[dict] = None) -&gt; FooSGIServer:\n        if module_dict:\n            cls._ensure_function_exists(web_app, module_dict)\n        return FooSGIServer(app=f\"{web_app.__qualname__}()\" if isinstance(web_app, Callable) else web_app)\n\n# Some code ...\n</code></pre> <p>Please take a look at the code line 10, it's the key line to let SGI server to catch which factory function it should use to generate the web application. Here usage should base on which way should use by your own customized Python web framework.</p> <ul> <li>Utility function in module <code>pymock_api.server.__init__</code></li> </ul> <pre><code># In module pymock_server.server.__init__\n\n# Some code ...\n\nfoo_app: \"foo_web_lib.Foo\" = None\n\n# Some code ...\n\ndef create_foo_app() -&gt; \"foo_web_lib.Foo\":\n    load_app.by_foo()\n    return foo_app\n\n# Some code ...\n\ndef setup_foosgi() -&gt; FooSGIServer:\n    return setup_server_gateway.foo(web_app=create_foo_app, module_dict=globals())\n\n# Some code ...\n\nclass load_app:\n\n    @classmethod\n    @ensure_importing(import_web_lib.foo_web_lib)\n    def by_foo(cls) -&gt; None:\n        global foo_app\n        config = cls._get_config_path()\n        foo_app = cls._initial_mock_server(config_path=config, app_server=FooWebLibrary()).web_app\n\n# Some code ...\n</code></pre> <p>The global variable <code>foo_app</code> is the variable which web application instance will be saved at. Function <code>create_foo_app</code> is the factory function to generate web application. Function <code>setup_foosgi</code> is the one which runs the web application which be set up by your own customized Python web framework.</p> <ul> <li>Add option value in one specific function in module <code>pymock_api.command.process</code></li> </ul> <p>Finally, we need to add a new value to let option <code>--app-type</code> could recognize and dispatch it to set up and run the web application by your own customized Python web framework.</p> <pre><code># In module pymock_server.command.process\n\n# Some code ...\n\nclass SubCmdRun(BaseCommandProcessor):\n\n    # Some code ...\n\n    def _initial_server_gateway(self, lib: str) -&gt; None:\n        if re.search(r\"auto\", lib, re.IGNORECASE):\n            web_lib = import_web_lib.auto_ready()\n            if not web_lib:\n                raise NoValidWebLibrary\n            self._initial_server_gateway(lib=web_lib)\n        elif re.search(r\"flask\", lib, re.IGNORECASE):\n            self._server_gateway = setup_wsgi()\n        elif re.search(r\"fastapi\", lib, re.IGNORECASE):\n            self._server_gateway = setup_asgi()\n        elif re.search(r\"foo\", lib, re.IGNORECASE):\n            self._server_gateway = setup_foosgi()\n        else:\n            raise InvalidAppType\n\n# Some code ...\n</code></pre> <p>All things you need to do is done! Let's try to run the command line to test its feature:</p> <pre><code>&gt;&gt;&gt; mock --app-type foo\n</code></pre> <p>If you could keep observing the log message which be generated by web application as you expect, congratulation you extend the feature successfully!</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>It's welcome to join PyMock-Server development and let it be better and better! Here section would tell you something which may be helpful in developing, troubleshooting, etc.</p> <ul> <li> <p>Developing</p> <p>What things you should do if you want to develop PyMock-Server. In honestly, it's just a suggestion, you also could develop by the way you feel great or be convenience if you already have experience at developing with Python. But, if you're new in Python, I believe it would be very helpful to you.</p> </li> <li> <p>Testing</p> <p>The reason why the testing is a single section is there's some rules for developing test code. We try to do the best at having great tests to deeply raising the quality and reliable of test for source code.</p> </li> <li> <p>Reporting a bug</p> <p>If you find any problem or something wrong of PyMock-Server, it's great to report it to us to fix it and provide better tool to everyone.</p> </li> <li> <p>Requesting a feature or change</p> <p>It's free to request any requirements includes a new feature or a feature change. We will collect all advances and have deeply consideration with it. If it's helpful in usage for user, be maintainable for developers, etc., we will implement it as soon as possible.</p> </li> </ul>"},{"location":"development/contributing/developing/","title":"Developing","text":"<p>Here are some guidelines for developing open source project PyMock-Server. It's very easy to start because PyMock-Server is managed by Poetry.</p>"},{"location":"development/contributing/developing/#requirements-for-development","title":"Requirements for development","text":"<p>PyMock-Server require Python version 3.8 up. Please make sure the Python version in your runtime environment.</p> Recommended: Use the latest Python version to develop <p>PyMock-Server only support Python version 3.8 +. If you're user, please make sure you're Python version should be newer than version 3.8. However, for developers, it strongly suggests you should upgrade your runtime environment Python to the latest version. We should not take too much time to develop with older version and the responsibility of the test running with older versions belong to CI tool. It does definitely not your job.</p> <p>On top of that, there are another 2 tools would suggest you to install it: PyEnv and Poetry.</p>"},{"location":"development/contributing/developing/#pyenv-python-versions-management","title":"PyEnv  - Python versions management","text":"<p>First of all, you should make sure that you have already installed PyEnv.</p> <pre><code>pyenv --version\n</code></pre> <p>If you don't, please install it.</p> <p>PyEnv is a great tool for strongly managing so many different Python versions in your runtime environment. With it, you could very quickly switch to different Python version to developing or troubleshooting with your Python code. That's very helpful to developers to develop a crossing Python version library or tool.</p> <p>After checking PyEnv, let's check next one tool: Poetry:</p>"},{"location":"development/contributing/developing/#poetry-python-project-dependency-management","title":"Poetry  - Python project dependency management","text":"<pre><code>poetry --version\n</code></pre> <p>If you don't install it, please install it.</p> <p>Poetry is a powerful tool for managing dependencies for Python project. It also could manage many things like other tool's configuration detail settings.</p>"},{"location":"development/contributing/developing/#set-python-runtime-environment","title":"Set Python runtime environment","text":"<p>Now, we have installed PyEnv and Poetry. We can:</p> <ul> <li>Use PyEnv to manage Python versions in our runtime environment.</li> <li>Use Poetry to manage the dependencies or other tool's configuration settings of our Python project.</li> </ul> <p>From above 2 statements, we also can:</p> <ul> <li>Use PyEnv to control which Python version runtime environment we would use to develop</li> <li>Use Poetry to configure project dependencies with current Python runtime environment</li> </ul> <p>So let's start to set the latest Python version in current environment.</p> <p>First, install the latest Python version:</p> <pre><code>pyenv install &lt;Python version&gt;\n</code></pre> <p>Verify what Python versions you have installed before</p> <p>You could verify the version info by below command:</p> <pre><code>pyenv versions\n</code></pre> <p>Second, create a virtual environment with the Python version.</p> <p>It suggests you create a virtual environment with one specific Python version for your project. That could help to let your project's dependency be independent of your local environment with one specific Python version. In other words, it would be convenience to create another virtual environment with other different Python version to develop or debug.</p> <pre><code>pyenv virtualenv &lt;Python version&gt; &lt;virtusl environment name&gt;\n</code></pre> <p>Let's access to the virtual environment and verify the Python version in it:</p> <pre><code>pyenv activate &lt;virtusl environment name&gt;\n</code></pre> <p>Check the Python version:</p> <pre><code>python --version\n</code></pre> <p>After we access to virtual environment and verify the Python version, we could install tool Poetry:</p> <pre><code>pip install poetry\n</code></pre> <p>Don't forget verify the tool function:</p> <pre><code>poetry --help\n</code></pre>"},{"location":"development/contributing/developing/#install-development-dependencies","title":"Install development dependencies","text":"<p>Now, we have already prepared the runtime environment and tools. And we should be in the virtual environment and tool Poetry has been ready for using. Let's start to install dependencies.</p> <p>It's very easy to install dependencies for the Python project be managed by Poetry. You only run the command line as following:</p> <pre><code>poetry install\n</code></pre> <p>It will take some time to install all dependencies the project needs. After it done, we could verify the dependencies:</p> <pre><code>poetry run pip list\n</code></pre> <p><code>pip</code> in virtual environment vs <code>pip</code> in Poetry shell</p> <p>The dependencies would be installed in Poetry shell, doesn't in virtual environment shell. Poetry would also help you create a virtual environment to set all configurations of your Python project. So if you verify the dependencies in currenct runtime environment directly, it is empty. That's why you should check it through command <code>poetry run</code>.</p>"},{"location":"development/contributing/developing/#verify-features","title":"Verify features","text":"<p>After finish all the above prerequisites, let's try to run the command line feature!</p> <p>We should activate the command line feature by 2 ways: run the directory of source code or run command line.</p>"},{"location":"development/contributing/developing/#run-the-directory-of-source-code","title":"run the directory of source code","text":"<p>PyMock-Server has entry point for package. So it could run the folder of source code directly.</p> Out of Poetry shellWithin Poetry shell <pre><code>poetry run ./pymock_api --help\n</code></pre> <pre><code>./pymock_api --help\n</code></pre>"},{"location":"development/contributing/developing/#run-command-line","title":"run command line","text":"<p>Run the command line directly to be closer in usage as a developers:</p> Out of Poetry shellWithin Poetry shell <pre><code>poetry run mock --help\n</code></pre> <pre><code>mock --help\n</code></pre> How to access into Poetry shell <p>You could access into Poetry shell as below command:</p> <pre><code>poetry shell\n</code></pre> <p>Congratulation! Right now you could start to do anything what you want to do of PyMock-Server project!</p>"},{"location":"development/contributing/reporting-a-bug/","title":"Reporting a bug","text":"<p>It doesn't exist any project which is perfect without any defects, it includes PyMock-Server. An open source project would be better and better with everyone's sustainable feedbacks and suggestions. Therefore, it's very kind of giving anything to us to improve PyMock-Server!</p>"},{"location":"development/contributing/reporting-a-bug/#before-creating-an-issue","title":"Before creating an issue","text":"<p>Before you create a bug report to us, here are checklist you need to check to ensure the issue is a real issue.</p>"},{"location":"development/contributing/reporting-a-bug/#os","title":"OS","text":"<p>Unfortunately, PyMock-Server doesn't support Windows OS currently. So any issues occur in Windows OS won't be fixed.</p>"},{"location":"development/contributing/reporting-a-bug/#python-version","title":"Python version","text":"<p>PyMock-Server only supports Python version 3.8 +. So please make sure the Python version in your current runtime environment is 3.8 +.</p>"},{"location":"development/contributing/reporting-a-bug/#pymock-server-version","title":"PyMock-Server version","text":"<p>Please upgrade to the latest version and verify the issue again if your PyMock-Server version is not latest. The issue may have been fixed in the latest version.</p>"},{"location":"development/contributing/reporting-a-bug/#report","title":"Report","text":"<p>If you have done all above checks and could reproduce your issue by steps, please create a bug report to us, and we would process it as soon as possible.</p> <p>\u00a0 Create a bug report</p>"},{"location":"development/contributing/requesting-a-feature/","title":"Requesting a feature or change","text":"<p>PyMock-Server is a newborn open source project. Its features are not complete at all. It still has so many issues need to implement or improve. So please be kind of proposing any idea of it!</p>"},{"location":"development/contributing/requesting-a-feature/#before-creating-an-issue","title":"Before creating an issue","text":"<p>Please don't forget, PyMock-Server is a tool for being humanly and easy to quickly set up a web server for mocking API with configuration only. Its target is let developers could set up a web server easily and quickly. So it hopes it could be used very easily, in the other words, it hopes it could do its best to reduce developer's burden of mocking API or managing the mocking configuration, etc. Therefore, it hopes all feature or change request should be concerned on it.</p>"},{"location":"development/contributing/requesting-a-feature/#report","title":"Report","text":"<p>If you have any good idea of implementing strong feature or improve something to be better, please request a feature or change to us, and we would process it as soon as possible.</p> <p>\u00a0 Request new feature or change</p>"},{"location":"development/contributing/testing/","title":"Testing","text":"<p>About the testing, PyMock-Server has some prerequisites or rules of it. PyMock-Server has 2 types test: unit test and integration test. Unit test are in directory test/unit_test and integration test are in directory test/integration_test.</p>"},{"location":"development/contributing/testing/#requirements-for-testing","title":"Requirements for testing","text":"<p>PyMock-Server uses test framework PyTest. So please make sure its tool <code>pytest</code> could work finely in your current runtime environment for development.</p> Out of Poetry shellWithin Poetry shell <pre><code>poetry run pytest --version\n</code></pre> <pre><code>pytest --version\n</code></pre> <p>Apart from PyTest, PyMock-Server also use another dependencies and some of them is PyTest plugin.</p> <ul> <li> <p>coverage</p> <p>For recording, calculating the test coverage of source code and generating report about it.</p> </li> <li> <p>pytest-cov</p> <p>Let PyTest supports all feature of coverage.</p> </li> <li> <p>pytest-rerunfailures</p> <p>Let PyTest supports re-run feature.</p> </li> </ul> <p>Please refer to the configuration pyproject.toml if you need.</p>"},{"location":"development/contributing/testing/#run-test","title":"Run test","text":"<p>It has 2 ways to run test when you develop PyMock-Server.</p>"},{"location":"development/contributing/testing/#specific-test-module","title":"Specific test module","text":"<p>If you're developing one independent feature and only want to run a single module test, you just need to run <code>pytest</code> with the file path.</p> Out of Poetry shellWithin Poetry shell <pre><code>poetry run pytest &lt;.py file path&gt;\n</code></pre> <pre><code>pytest &lt;.py file path&gt;\n</code></pre> <p>If you just want to one specific test item, you could use option <code>-k</code>.</p> Out of Poetry shellWithin Poetry shell <pre><code>poetry run pytest &lt;.py file path&gt; -k 'test_item'\n</code></pre> <pre><code>pytest &lt;.py file path&gt; -k 'test_item'\n</code></pre> <p>Run test more efficiency</p> <p>In default from the PyTest configuration of PyMock-Server, it would re-run the test 3 times if it get fail at running the test. For being convenience at developing, you could set value as <code>0</code> at option <code>--reruns</code>.</p> <pre><code>pytest &lt;.py file path&gt; --reruns 0\n</code></pre>"},{"location":"development/contributing/testing/#all-the-one-specific-test-type-tests","title":"All the one specific test type tests","text":"<p>After you finish development of one or more features, it suggests you to run all tests to guarantee that you don't break up the code. If you want to run all tests, you would need to use shell script scripts/run_all_tests.sh to reach it. The shell script accept one argument --- test type. You have 3 types value could use:</p> <ul> <li> <p>all-test</p> <p>Run entire all tests under directory test.</p> </li> <li> <p>unit-test</p> <p>Run all unit tests and the test modules are in directory test/unit_test.</p> </li> <li> <p>integration-test</p> <p>Run all integration tests and the test modules are in directory test/integration_test.</p> </li> <li> <p>system-test</p> <p>Run all system tests and the test modules are in directory test/system_test.</p> </li> </ul> Out of Poetry shellWithin Poetry shell <pre><code>poetry run bash ./scripts/run_all_tests.sh &lt;test type&gt;\n</code></pre> <pre><code>bash ./scripts/run_all_tests.sh &lt;test type&gt;\n</code></pre>"},{"location":"development/contributing/testing/#how-to-add-test-sub-package","title":"How to add test sub-package?","text":"<p>It would auto-detect the test sub-packages and test modules under test directory. So we don't do anything and just add  the new test sub-package or test module directly.</p> <p>You will see the running result includes the new path of all test modules which are in new test sub-package.</p> <pre><code>&gt;&gt;&gt; bash ./scripts/ci/&lt;the shell script what you modify&gt; 'unix'\n</code></pre> <p>Argument of shell script</p> <p>It has an argument of the shell script about what OS the current runtime environment is in.</p> <ul> <li> <p><code>unix</code></p> <p>For Unix OS or MacOS.</p> </li> <li> <p><code>windows</code></p> <p>For Windows OS.</p> </li> </ul>"},{"location":"getting-started/configure-your-api/","title":"Configure your APIs","text":"<p>It configures the detail settings of PyMock-Server by YAML syntax, and must have either a <code>.yml</code> or <code>.yaml</code> file extension. If you're new to YAML and want to learn more, see \"Learn YAML in Y minutes.\"</p>"},{"location":"getting-started/configure-your-api/#what-settings-are-necessary","title":"What settings are necessary?","text":"<p>This question also means what an API need? In generally, the necessary conditions it needs as following:</p> <ul> <li>The URL path</li> <li>The HTTP attributes<ul> <li>HTTP request</li> <li>HTTP response</li> </ul> </li> </ul> <p>Therefore, above properties also are the options we must configure by YAML syntax for mocking API.</p>"},{"location":"getting-started/configure-your-api/#configure-api","title":"Configure API","text":"<p>First of all, create a file with YAML extension <code>.yaml</code>.</p> <p>All the API settings need to be configured under key <code>mocked_apis</code> and it would be a list of key-value map type elements. The key is the API name and the value is the detail settings of the API.</p> <pre><code>mocked_apis:\n  &lt;API name&gt;: &lt;API settings&gt;\n</code></pre> <p>Before start to configure, let's give a usage scenario: </p> <p>Mock an API which accepts GET method without any parameter, and it would return string value <code>This is Foo home API.</code>. We could sort out the requirement as 3 conditions as below:</p> <ul> <li>URL path: /foo</li> <li>HTTP request method: GET</li> <li>HTTP response data: This is Foo home API.</li> </ul> <p>Let's name the API as <code>foo_home</code>:</p> <pre><code>mocked_apis:\n  foo_home: &lt;foo API settings&gt;\n</code></pre>"},{"location":"getting-started/configure-your-api/#url","title":"URL","text":"<p>In the API setting section, it uses key <code>url</code> to configure the URL path. So we could set <code>/foo</code> directly here:</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo'\n</code></pre> <p>We have done the first condition! Let's quickly set the next one setting about HTTP.</p> <ul> <li> URL path: /foo</li> <li> HTTP request method: GET</li> <li> HTTP response data: This is Foo home API.</li> </ul>"},{"location":"getting-started/configure-your-api/#http","title":"HTTP","text":"<p>About the HTTP settings, it has multiple options could configure. So key <code>http</code> manages all settings about HTTP settings and more details under it.</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo'\n    http: &lt;HTTP settings&gt;\n</code></pre> <p>In basically, there are 2 options we must configure: HTTP request and HTTP response. It also has 2 keys <code>request</code> and <code>response</code> to manage them.</p>"},{"location":"getting-started/configure-your-api/#request","title":"Request","text":"<p>All the HTTP request settings would be managed under key <code>http.request</code>. And right now, we just need to set one attribute <code>method</code> about the HTTP method:</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo'\n    http:\n      request:\n        method: 'GET'\n</code></pre> <p>We have done the second condition! It leaves only one condition about HTTP response.</p> <ul> <li> URL path: /foo</li> <li> HTTP request method: GET</li> <li> HTTP response data: This is Foo home API.</li> </ul>"},{"location":"getting-started/configure-your-api/#response","title":"Response","text":"<p>All the HTTP response settings would be managed under key <code>http.response</code>. About the HTTP response configuration, it has  multiple strategies for setting the return  value format. For easily and quickly demonstrating the HTTP response setting, let's use <code>string</code> strategy right now.</p> <pre><code>mocked_apis:\n  foo_home:\n    url: '/foo'\n    http:\n      request:\n        method: 'GET'\n      response:\n        strategy: string\n        value: 'This is Foo home API.'\n</code></pre> <p>Congratulation! We finish the configuration for mocking API, and we could try to set up the web server to provide the mocking service!</p> <ul> <li> URL path: /foo</li> <li> HTTP request method: GET</li> <li> HTTP response data: This is Foo home API.</li> </ul>"},{"location":"getting-started/configure-your-api/#check-configuration-validation","title":"Check configuration validation","text":"<p>If you're meticulous in configuring and developing, PyMock-Server also provide a command line to help you check your configuration validation:</p> <pre><code>mock rest-server check -p &lt;configuration path&gt;\n</code></pre> <p>It would check everywhere of configuration and make sure your configuration is valid for running.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#with-pip","title":"With pip for general usage","text":"<p>pip is a Python package management tool. We could install all the Python packages which be managed in PyPI platform. So we also could install PyMock-Server via pip as below command:</p> <pre><code>pip install pymock-server\n</code></pre> <p>However, it may have something problems:</p> <ul> <li>It would install all the dependencies which may includes something you don't need. </li> </ul> <p>So it recommends that installs PyMock-Server by pip with option to install the necessary dependencies only.</p> <pre><code>pip install \"pymock-server[&lt;web framework&gt;]\"\n</code></pre> <p>The dependencies which are necessary to install decreases greatly.</p> <p>What the option web framework we could use?</p> <p>PyMock-Server uses the Python web framework to implement the API feature. It means that it would also depend  on other Python package which for web development. Currrently, it supports 2 frameworks of all popular Python web  framerworks --- Flask and FastAPI. So the options value we could use are: <code>mini</code>, <code>auto</code>,  <code>flask</code> or <code>fastapi</code>.</p> <ul> <li> <p><code>mini</code></p> <p>It would install the minimum level depdendency of Python package. It also means it won't install both of web  frameworks Flask or FastAPI.</p> </li> <li> <p><code>auto</code></p> <p>The option <code>auto</code> means that it would automatically scan which Python web framework it would use in the current  Python runtime environment where the command line tool runs in.</p> </li> </ul>"},{"location":"getting-started/installation/#with-poetry","title":"With poetry recommended for Python developer","text":"<p>If you're familiar with Python, it strongly recommends that use Poetry to manage your Python project includes installing this package.</p> So what is Poetry ...? <p>If you still miss your direction about how to manage your Python project, you must try to use Poetry to do it. Poetry is a tool for managing your Python project includes the deeply complex relations of Python dependencies.</p> <p>Let's quickly demonstrate the general usage of Poetry to you.</p> <p>If you want to add a new dependency, in the other words, install a new Python package, it doesn't use <code>pip</code>, use <code>poetry</code> to add it.</p> <pre><code>poetry add &lt;Python package&gt;\n</code></pre> <p>How easy it is! Isn't it? It's also easy for removing dependency:</p> <pre><code>poetry remove &lt;Python package&gt;\n</code></pre> <p>So what's the difference between Poetry and pip? The major difference is Poetry could be greatly better to manage your dependencies! Let's consider a scenario. If a package A which depends on pacakge B, it would also install package B when it installs pacakge A. However, about removing this package, it's a trouble when you use pip because pip won't remove package B when you remove package A! You need to manually remove package B if you want to remove them clearly. If your project is huge, it's also a big problem of managing your project's dependencies. And the poetry is a great solution to resolve this issue. Poetry even sorts out the dependencies relations as a tree diagram and illustrate it as following:</p> <pre><code>&gt;&gt;&gt; poetry show --tree --without=dev\nfastapi 0.95.2 FastAPI framework, high performance, easy to learn, fast to code, ready for production\n\u251c\u2500\u2500 email-validator &gt;=1.1.1\n\u2502   \u251c\u2500\u2500 dnspython &gt;=2.0.0\n\u2502   \u2514\u2500\u2500 idna &gt;=2.0.0\n\u251c\u2500\u2500 httpx &gt;=0.23.0\n\u2502   \u251c\u2500\u2500 certifi *\n\u2502   \u251c\u2500\u2500 httpcore &gt;=0.15.0,&lt;0.18.0\n\u2502   \u2502   \u251c\u2500\u2500 anyio &gt;=3.0,&lt;5.0\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 idna &gt;=2.8\n...\n</code></pre> <p>How clear it is! So Poetry is a very powerful tool for manage your Python project.</p> <p>The installing command is little different with <code>pip</code> but be similar:</p> <pre><code>poetry add pymock-server\n</code></pre> <p>It also could install necessary parts of dependencies only.</p> <pre><code>poetry add \"pymock-server[&lt;web framework&gt;]\"\n</code></pre> <p>It should add one more dependency PyMock-Server in your configuration pyproject.toml.</p>"},{"location":"getting-started/installation/#with-git","title":"With git","text":"<p>If you want to use the latest features of PyMock-Server, you could use <code>git</code> to clone the project's source code first.</p> <pre><code>git clone https://github.com/Chisanan232/PyMock-Server.git ./pymock-server -b &lt;git branch&gt;\n</code></pre> <p>The dividing rule of git branch</p> <p>It apply Trunk-base developmenet at PyMock-Server project and its trunk branch is master.:</p> <p></p> <ul> <li>develop<ul> <li>Git branch: develop/**</li> <li>Majot process: All the development should base on this branch to work. The code of this branch always be latest but also unstable.</li> </ul> </li> <li>master<ul> <li>Git branch: master (it's also trunk branch)</li> <li>Majot process: The final code to release to PyPI incudes documentation. The code of this branch is stablest and it also be same as the code in PyPI.</li> </ul> </li> </ul> <p>After source code be ready, you could install it by <code>pip</code>.</p> <pre><code>pip install -e pymock-server\n</code></pre>"},{"location":"getting-started/installation/#with-docker","title":"With Docker for general usage without Python runtime environment","text":"<p>If your runtime environment has not installed Python and you won't use Python temporarily, you also could use Docker to enjoy PyMock-Server.</p> <p>Download PyMock-Server official image as below:</p> <pre><code>docker pull pymock-server:v0.1.0\n</code></pre> Recommended: Use the tag to manage your Docker image <p>You could use command line <code>docker pull pymock-server</code> without tag absolutely. But the default tag is <code>latest</code>. That means you cannot clear what version you have currently. So it recommends using tag to manage it and clear what version it use currently by yourself.</p> <p>Verify the Docker image has been exactly installed:</p> <pre><code>docker images pymock-server\n</code></pre>"},{"location":"getting-started/installation/#verify-the-command-line-feature","title":"Verify the command line feature","text":"<p>No matter which way to install PyMock-Server, it must verify whether the command line tool is ready for working or not.</p> <pre><code>mock --help\n</code></pre> <p>If it outputs some usage info about the command <code>mock</code>, congratulation! You could start to enjoy easily and quickly mock API.</p>"},{"location":"getting-started/setup-web-server/","title":"Set up web server","text":"<p>If your configuration be ready to mock, it's time to set up a web server to mock them and provides this service to outside!</p>"},{"location":"getting-started/setup-web-server/#run-by-cli","title":"Run by CLI","text":"<p>It's very easy to set up and run the web server by PyMock-Server. With default setting, namely using default value <code>auto</code> of option <code>--app-type</code>, it would automatically detect which the Python web framework it can use in the current runtime environment. Therefore, the running server log message would be different with different Python web framework.</p> FlaskFastAPI <pre><code>&gt;&gt;&gt; mock rest-server run -p &lt;configuration path&gt;\n[2023-06-06 21:55:53 +0800] [78900] [INFO] Starting gunicorn 20.1.0\n[2023-06-06 21:55:53 +0800] [78900] [INFO] Listening at: http://127.0.0.1:9672 (78900)\n[2023-06-06 21:55:53 +0800] [78900] [INFO] Using worker: sync\n[2023-06-06 21:55:53 +0800] [78915] [INFO] Booting worker with pid: 78915\n</code></pre> <pre><code>&gt;&gt;&gt; mock rest-server run -p &lt;configuration path&gt;\nINFO:     Started server process [78594]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:9672 (Press CTRL+C to quit)\n</code></pre> <p>After running the web server, let's try to send HTTP request by command line <code>curl</code> to the API and verify its feature.</p> <pre><code>&gt;&gt;&gt; curl -X GET http://127.0.0.1:9672/foo\n\"This is Foo home API.\"%\n</code></pre>"},{"location":"getting-started/setup-web-server/#run-by-docker","title":"Run by Docker","text":"<p>Although Docker is easy, but we should be careful to use it with options. It has three options are necessary you must use:</p> <ul> <li> <p><code>-v</code></p> <p>Mount the configuration of mocked APIs into container. By Docker's rule, you need to use absolute path here. For the target path it would mount to, it must be in directory <code>/mit-pymock-server/</code> because where is the command line works  at.</p> </li> <li> <p><code>-e</code></p> <p>Set environment variable into container. It has some parameters it provides to use.</p> <ul> <li> <p>CONFIG_PATH</p> <p>The configuration path. By default, it would try to use file <code>api.yaml</code> in the root directory where it works at. In the other words, it would try to find the file <code>/mit-pymock-server/api.yaml</code> in Docker container in default.</p> </li> <li> <p>WEB_FRAMEWORK</p> <p>Which Python web framework it should use to set up server. By default, it would use <code>auto</code> to do it.</p> </li> <li> <p>WORKERS</p> <p>How many workers it should use to process HTTP requests. By default, its value is <code>1</code>.</p> </li> <li> <p>LOG_LEVEL</p> <p>The log level of web server it should export. By default, its value is <code>info</code>.</p> </li> </ul> </li> <li> <p><code>-p</code></p> <p>It needs to export the port number <code>9672</code> of web server so that it can provide the service to mock APIs for outside.</p> </li> </ul> <p>Let's give you a sample command line to set up mock server by Docker:</p> <pre><code>&gt;&gt;&gt; docker run --name mock-server \\\n               -v &lt;configuration root directory&gt;:/mit-pymock-server/&lt;configuration root directory&gt; \\\n               -e CONFIG_PATH=&lt;configuration path&gt;\n               -p 9672:9672 \\\n               pymock-server:v0.1.0\n</code></pre> Hint: Still being confused about the configuration path setting? Let's demonstrate some usage scenarios to you. <p>Assume that we have below files tree:</p> <pre><code>local root directory (/User/foo/mock-api-demo)\n\u251c\u2500\u2500 file1\n\u251c\u2500\u2500 file2\n\u251c\u2500\u2500 api.yaml\n\u251c\u2500\u2500 folder1\n\u2502   \u251c\u2500\u2500 file3\n\u2502   \u251c\u2500\u2500 file4\n\u2502   \u2514\u2500\u2500 beta-api.yaml\n</code></pre> <ul> <li>Scenario 1: Use the configuration <code>api.yaml</code></li> </ul> <p>Your command line would be like below:</p> <pre><code>&gt;&gt;&gt; docker run --name mock-server \\\n               -v /User/foo/mock-api-demo:/mit-pymock-server \\\n               -p 9672:9672 \\\n               pymock-server:v0.1.0\n</code></pre> <p>You can mount the all files in folder <code>/User/foo/mock-api-demo</code> into folder <code>/mit-pymock-server</code> of container. And the file tree in container would be as below:</p> <pre><code>container root directory (/)\n\u251c\u2500\u2500 mit-pymock-server\n\u2502   \u251c\u2500\u2500 file1\n\u2502   \u251c\u2500\u2500 file2\n\u2502   \u251c\u2500\u2500 api.yaml\n\u2502   \u2514\u2500\u2500 folder1\n|       \u251c\u2500\u2500 file3\n|       \u251c\u2500\u2500 file4\n\u2502       \u2514\u2500\u2500 beta-api.yaml\n</code></pre> <p>Do you remember the command line working directory is <code>mit-pymock-server</code> and the default value is <code>api.yaml</code> of environment <code>CONFIG_PATH</code>? And it exactly has a file at path <code>mit-pymock-server/api.yaml</code> so it would set up server successfully!</p> <ul> <li>Scenario 2: Use the configuration <code>beta-api.yaml</code></li> </ul> <p>If you try to set up server by configuration <code>beta-api.yaml</code>, your command line would be like below:</p> <pre><code>&gt;&gt;&gt; docker run --name mock-server \\\n               -v /User/foo/mock-api-demo:/mit-pymock-server \\\n               -e CONFIG_PATH=./folder1/beta-api.yaml\n               -p 9672:9672 \\\n               pymock-server:v0.1.0\n</code></pre> <p>The mount setting is the same as previous scenario so the file tree also be the same as previous one. And the command line working directory is <code>mit-pymock-server</code>. So we just need to give it a relative path in working directory. Therefore, the value would be <code>./folder1/beta-api.yaml</code>.</p> <p>What the detail usage of PyMock-Server by Docker?</p> <p>Please refer to PyMock-Server's image overview in Docker hub to get more details.</p> <p>Great! Now the web server for mocking your API has done, and it would start to provide this service for other projects or services.</p>"},{"location":"getting-started/version-requirements/","title":"Getting started","text":"<p>Actually, PyMock-Server is a Python package which provides command line tool. So it still needs to install a Python package to activate the command line feature.</p>"},{"location":"getting-started/version-requirements/#version-requirements","title":"Version requirements","text":"<p>PyMock-Server only supports Python 3.8 and newer version.</p> <p>PyMock-Server is a Python package which base on some giants to design and develop. It's obvious at the option <code>--app-type</code> which acceptable values are <code>flask</code> or <code>fastapi</code>. In the other words, the code base depends on these 2 web framework to implement. And also be limited by these 2 Python package's versions.</p> <p>It could refer to the documentation about the Python version it supports of these 2 packages:</p> <ul> <li>Flask</li> </ul> <p>We recommend using the latest version of Python. Flask supports Python 3.8 and newer.We recommend using the latest version of Python. Flask supports Python 3.8 and newer.</p> <p>Here is the reference about Python version it recommends.</p> <ul> <li>FastAPI</li> </ul> <p>It's very short and clear:</p> <p>Python 3.7+</p> <p>Here is the reference about Python version it recommends.</p> <p>That's the reason why PyMock-Server supports Python 3.8 and newer. It needs to support both of these Python web frameworks.</p>"},{"location":"getting-started/version-requirements/#control-version","title":"Control version","text":"<p>Sometimes, it needs to run code with different Python versions. It strongly recommends using a tool PyEnv to manage our Python version with current project.</p>"},{"location":"getting-started/version-requirements/#pyenv-control-and-manage-python-runtime-environment","title":"PyEnv - Control and manage Python runtime environment","text":"<p>It's a great tool of managing Python version for current runtime environment. It could be easily and quickly to switch current Python runtime environment and manage multiple versions.</p> <p>Please refer to the documentation of PyEnv to get more details. </p>"},{"location":"getting-started/version-requirements/#poetry-manage-python-projects-dependencies","title":"Poetry - Manage Python project's dependencies","text":"<p>Why it also recommends using Poetry? It doesn't mean only use one of tools PyEnv or Poetry. It strongly recommends to use both of them! Why? PyEnv could help you control and manage your current Python runtime environment, and Poetry could strongly manage your project's dependencies. So you will be convenience and efficiency to develop and manage your Python project.</p> <p>Here is the documentation of Poetry. </p>"},{"location":"release_note/","title":"Release notes","text":"<p>All release information includes what it adds, changes or something else would be recorded here.</p> <p>Following are the changes log of each major version:</p>"},{"location":"release_note/#version-0xx","title":"Version 0.X.X","text":"<p>The change logs for all version 0.X.X.</p>"},{"location":"release_note/version_0xx/","title":"Version 0.X.X","text":""},{"location":"release_note/version_0xx/#020","title":"0.2.0","text":""},{"location":"release_note/version_0xx/#new-feature","title":"\ud83c\udf89\ud83c\udf8a\ud83c\udf7e New feature","text":"<ol> <li>Support parsing version2 (aka Swagger) and version3 OpenAPI document configuration.</li> <li>Support nested data structure about collection data types, i.e., <code>list</code> or <code>dict</code>, in response.</li> <li>Add new command line argument <code>--source-file</code> in sub-command line <code>pull</code> for being more convenience to pull configuration for PyMock-API.</li> <li>Let sub-command line <code>add</code> support dividing feature.</li> </ol>"},{"location":"release_note/version_0xx/#bug-fix","title":"\ud83d\udee0\ud83d\udc1b\ud83d\udca3 Bug Fix","text":"<ol> <li>Fix some issues.</li> <li>It cannot parse finely at the empty body of one specific column in response.</li> <li>Fix broken tests.</li> <li>Fix incorrect serializing logic if request parameter or body is empty.</li> <li>Fix incorrect checking logic at configuration validation in sub-command line <code>check</code>.</li> <li>Fix the issue about it cannot work finely with argument <code>--base-file-path</code> in sub-command line <code>pull</code>.</li> </ol>"},{"location":"release_note/version_0xx/#improvement","title":"\ud83e\udd16\u2699\ufe0f\ud83d\udd27 Improvement","text":"<ol> <li>Upgrade the dependencies.</li> <li>Upgrade the reusable workflows in CI workflow.</li> <li>Extract the logic about initialing test data for testing as modules.</li> </ol>"},{"location":"release_note/version_0xx/#docs","title":"\ud83d\udcdd\ud83d\udcd1\ud83d\udcd7Docs","text":"<ol> <li>Update the content for new feature.</li> </ol>"},{"location":"release_note/version_0xx/#010","title":"0.1.0","text":""},{"location":"release_note/version_0xx/#new-feature_1","title":"\ud83c\udf89\ud83c\udf8a\ud83c\udf7e New feature","text":"<ol> <li> <p>Provide command line interface <code>mock-api</code> for mocking HTTP server.</p> <pre><code>usage: mock-api [SUBCOMMAND] [OPTIONS]\n\nA Python tool for mocking APIs by set up an application easily. PyMock-API bases on Python web framework to set up application, i.e., you could select using *flask* to set up application to mock APIs.\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --version         The version info of PyMock-API.\n\nSubcommands:\n\n  {run,sample,add,check,get,pull}\n    run                 Set up APIs with configuration and run a web application to mock them.\n    sample              Quickly display or generate a sample configuration helps to use this tool.\n    add                 Something processing about configuration, i.e., generate a sample configuration or validate configuration content.\n    check               Check the validity of *PyMock-API* configuration.\n    get                 Do some comprehensive inspection for configuration.\n    pull                Pull the API details from one specific source, e.g., Swagger API documentation.\n</code></pre> </li> <li> <p>Provide documentation for details of the project.</p> </li> </ol>"}]}